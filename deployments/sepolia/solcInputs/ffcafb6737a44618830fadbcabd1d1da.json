{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/access/Owned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.23;\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    constructor (address _owner) {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n}"
    },
    "contracts/access/OwnedUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.23;\n\ncontract OwnedUpgradeable {\n    address public owner;\n    address public nominatedOwner;\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    function __Owned_init(address _owner) internal {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n}\n"
    },
    "contracts/apps/VeUnoDaoYieldDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.23;\n\n// Originally inspired by Synthetix.io, but heavily modified by the UNO team\n// https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {OwnedUpgradeable} from \"../access/OwnedUpgradeable.sol\";\nimport {IVotingEscrow} from \"../interfaces/dao/IVotingEscrow.sol\";\n\ncontract VeUnoDaoYieldDistributor is OwnedUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n\n    struct LockedBalance {\n        int128 amount;\n        uint256 end;\n    }\n\n    // Constant for price precision\n    uint256 public constant PRICE_PRECISION = 1e6;\n\n    // Stores last reward time of staker\n    mapping(address => uint256) public lastRewardClaimTime;\n    // Vote escrow contract, used for voting power\n    IVotingEscrow public veUNO;\n    // Reward token which staker earns for staking Uno\n    IERC20 public emittedToken;\n    // Yield and period related\n    uint256 public periodFinish;\n    uint256 public lastUpdateTime;\n    uint256 public yieldRate;\n    uint256 public yieldDuration;\n    // Yield tracking\n    uint256 public yieldPerVeUNOStored;\n    mapping(address => uint256) public userYieldPerTokenPaid;\n    mapping(address => uint256) public yields;\n    // veUNO tracking\n    uint256 public totalVeUNOParticipating;\n    uint256 public totalVeUNOSupplyStored;\n    mapping(address => uint256) public userVeUNOCheckpointed;\n    mapping(address => uint256) public userVeUNOEndpointCheckpointed;\n    mapping(address => bool) public userIsInitialized;\n    // Greylists\n    mapping(address => bool) public greylist;\n    // Admin booleans for emergencies\n    bool public yieldCollectionPaused; // For emergencies, by default \"False\"\n    // Used to change secure states\n    address public timelock;\n    // Stores user's flag for reward apy update\n    mapping(address => bool) public rewardNotifiers;\n\n    event RewardAdded(uint256 reward, uint256 yieldRate);\n    event YieldCollected(\n        address indexed user,\n        uint256 yieldAmount,\n        address token\n    );\n    event YieldDurationUpdated(uint256 newDuration);\n    event RecoveredERC20(address token, uint256 amount);\n\n    modifier onlyByOwnGov() {\n        require(\n            msg.sender == owner || msg.sender == timelock,\n            \"VeUnoYD: !O/T\"\n        );\n        _;\n    }\n\n    modifier notYieldCollectionPaused() {\n        require(!yieldCollectionPaused, \"VeUnoYD: YCP\");\n        _;\n    }\n\n    modifier checkpointUser(address _account) {\n        _checkpointUser(_account);\n        _;\n    }\n\n    function initialize(IERC20 _emittedToken, IVotingEscrow _veUNO, address _timelock, address _owner) external initializer {\n        emittedToken = _emittedToken;\n        veUNO = _veUNO;\n        timelock = _timelock;\n        lastUpdateTime = block.timestamp;\n        rewardNotifiers[msg.sender] = true;\n        yieldDuration = 604800; // 7 * 86400  (7 days)\n        __Owned_init(_owner);\n    }\n\n    function sync() public {\n        // Update the total veUNO supply\n        yieldPerVeUNOStored = yieldPerVeUNO();\n        totalVeUNOSupplyStored = veUNO.totalSupply();\n        lastUpdateTime = lastTimeYieldApplicable();\n    }\n\n    // Only positions with locked veUNO can accrue yield. Otherwise, expired-locked veUNO\n    function eligibleCurrentVeUNO(\n        address _account\n    )\n        public\n        view\n        returns (uint256 eligibleVeUnoBal, uint256 storedEndTimestamp)\n    {\n        uint256 currVeUnoBal = veUNO.balanceOf(_account);\n\n        // Stored is used to prevent abuse\n        storedEndTimestamp = userVeUNOEndpointCheckpointed[_account];\n\n        // Only unexpired veUNO should be eligible\n        if (\n            storedEndTimestamp != 0 && (block.timestamp >= storedEndTimestamp)\n        ) {\n            eligibleVeUnoBal = 0;\n        } else if (block.timestamp >= storedEndTimestamp) {\n            eligibleVeUnoBal = 0;\n        } else {\n            eligibleVeUnoBal = currVeUnoBal;\n        }\n    }\n\n    function lastTimeYieldApplicable() public view returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish; // return min value\n    }\n\n    function yieldPerVeUNO() public view returns (uint256 yield) {\n        if (totalVeUNOSupplyStored == 0) {\n            yield = yieldPerVeUNOStored;\n        } else {\n            yield =\n                yieldPerVeUNOStored +\n                (((lastTimeYieldApplicable() - lastUpdateTime) *\n                    yieldRate *\n                    1e18) / totalVeUNOSupplyStored);\n        }\n    }\n\n    function earned(\n        address _account\n    ) public view returns (uint256 yieldAmount) {\n        // Uninitialized users should not earn anything yet\n        if (!userIsInitialized[_account]) return 0;\n\n        // Get eligible veUNO balances\n        (\n            uint256 eligibleCurrentVeUno,\n            uint256 endTimestamp\n        ) = eligibleCurrentVeUNO(_account);\n\n        // If your veUNO is unlocked\n        uint256 eligibleTimeFraction = PRICE_PRECISION;\n        if (eligibleCurrentVeUno == 0) {\n            // And you already claimed after expiration\n            if (lastRewardClaimTime[_account] >= endTimestamp) {\n                // You get NOTHING. You LOSE. Good DAY ser!\n                return 0;\n            }\n            // You haven't claimed yet\n            else {\n                uint256 eligibleTime = endTimestamp -\n                    lastRewardClaimTime[_account];\n                uint256 totalTime = block.timestamp -\n                    lastRewardClaimTime[_account];\n                eligibleTimeFraction =\n                    (eligibleTime * PRICE_PRECISION) /\n                    totalTime;\n            }\n        }\n\n        // If the amount of veUNO increased, only pay off based on the old balance\n        // Otherwise, take the midpoint\n        uint256 veUnoBalanceToUse;\n        {\n            uint256 oldVeUnoBalance = userVeUNOCheckpointed[_account];\n            if (eligibleCurrentVeUno > oldVeUnoBalance) {\n                veUnoBalanceToUse = oldVeUnoBalance;\n            } else {\n                veUnoBalanceToUse =\n                    (eligibleCurrentVeUno + oldVeUnoBalance) /\n                    2;\n            }\n        }\n\n        yieldAmount =\n            yields[_account] +\n            ((veUnoBalanceToUse *\n                (yieldPerVeUNO() - userYieldPerTokenPaid[_account]) *\n                eligibleTimeFraction) / (PRICE_PRECISION * 1e18));\n    }\n\n    // Anyone can checkpoint another user\n    function checkpointOtherUser(address _user) external {\n        _checkpointUser(_user);\n    }\n\n    // Checkpoints the user\n    function checkpoint() external {\n        _checkpointUser(msg.sender);\n    }\n\n    function getYield()\n        external\n        nonReentrant\n        notYieldCollectionPaused\n        checkpointUser(msg.sender)\n        returns (uint256 yield0)\n    {\n        require(!greylist[msg.sender], \"VeUnoYD: GLU\");\n\n        yield0 = yields[msg.sender];\n\n        if (yield0 > 0) {\n            yields[msg.sender] = 0;\n            emittedToken.safeTransfer(msg.sender, yield0);\n            emit YieldCollected(msg.sender, yield0, address(emittedToken));\n        }\n\n        lastRewardClaimTime[msg.sender] = block.timestamp;\n    }\n\n    function notifyRewardAmount(address _user, uint256 _amount) external {\n        // Only whitelisted addresses can notify rewards\n        require(rewardNotifiers[msg.sender], \"VeUnoYD: !Notifier\");\n\n        // Handle the transfer of emission tokens via `transferFrom` to reduce the number\n        // of transactions required and ensure correctness of the emission amount\n        emittedToken.safeTransferFrom(_user, address(this), _amount);\n\n        // Update some values beforehand\n        sync();\n\n        // Update the new yieldRate\n        if (block.timestamp >= periodFinish) {\n            yieldRate = _amount / yieldDuration;\n        } else {\n            uint256 remaining = periodFinish - block.timestamp;\n            uint256 leftover = remaining * yieldRate;\n            yieldRate = (_amount + leftover) / yieldDuration;\n        }\n\n        // Update duration-related info\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp + yieldDuration;\n\n        emit RewardAdded(_amount, yieldRate);\n    }\n\n    function fractionParticipating() external view returns (uint256) {\n        return\n            (totalVeUNOParticipating * PRICE_PRECISION) /\n            totalVeUNOSupplyStored;\n    }\n\n    function getYieldForDuration() external view returns (uint256) {\n        return yieldRate * yieldDuration;\n    }\n\n    function _checkpointUser(address _account) internal {\n        // Need to retro-adjust some things if the period hasn't been renewed, then start a new one\n        sync();\n\n        // Calculate the earnings first\n        _syncEarned(_account);\n\n        // Get the old and the new veUNO balances\n        uint256 oldVeUnoBalance = userVeUNOCheckpointed[_account];\n        uint256 newVeUnoBalance = veUNO.balanceOf(_account);\n\n        // Update the user's stored veUNO balance\n        userVeUNOCheckpointed[_account] = newVeUnoBalance;\n\n        // Update the user's stored ending timestamp\n        IVotingEscrow.LockedBalance memory userCurrentLockedInfo = veUNO.locked(\n            _account\n        );\n        userVeUNOEndpointCheckpointed[_account] = userCurrentLockedInfo.end;\n\n        // Update the total amount participating\n        if (newVeUnoBalance >= oldVeUnoBalance) {\n            uint256 weightDiff = newVeUnoBalance - oldVeUnoBalance;\n            totalVeUNOParticipating = totalVeUNOParticipating + weightDiff;\n        } else {\n            uint256 weightDiff = oldVeUnoBalance - newVeUnoBalance;\n            totalVeUNOParticipating = totalVeUNOParticipating - weightDiff;\n        }\n\n        // Mark the user as initialized\n        if (!userIsInitialized[_account]) {\n            userIsInitialized[_account] = true;\n            lastRewardClaimTime[_account] = block.timestamp;\n        }\n    }\n\n    function _syncEarned(address _account) internal {\n        if (_account != address(0)) {\n            uint256 earned0 = earned(_account);\n            yields[_account] = earned0;\n            userYieldPerTokenPaid[_account] = yieldPerVeUNOStored;\n        }\n    }\n\n    // Added to support recovering LP Yield and other mistaken tokens from other systems to be distributed to holders\n    function recoverERC20(\n        IERC20 _token,\n        uint256 _amount\n    ) external onlyByOwnGov {\n        // Only the owner address can receive the recovery withdrawal\n        _token.safeTransfer(owner, _amount);\n        emit RecoveredERC20(address(_token), _amount);\n    }\n\n    function setYieldDuration(uint256 _yieldDuration) external onlyByOwnGov {\n        require(block.timestamp > periodFinish, \"VeUnoYD: !PYPC\");\n        yieldDuration = _yieldDuration;\n        emit YieldDurationUpdated(_yieldDuration);\n    }\n\n    function toggleGreylist(address _user) external onlyByOwnGov {\n        greylist[_user] = !greylist[_user];\n    }\n\n    function toggleRewardNotifier(address _notifier) external onlyByOwnGov {\n        rewardNotifiers[_notifier] = !rewardNotifiers[_notifier];\n    }\n\n    function setPauses(bool _yieldCollectionPaused) external onlyByOwnGov {\n        yieldCollectionPaused = _yieldCollectionPaused;\n    }\n\n    function setYieldRate(\n        uint256 _newRate0,\n        bool _isSync\n    ) external onlyByOwnGov {\n        yieldRate = _newRate0;\n\n        if (_isSync) {\n            sync();\n        }\n    }\n\n    function setTimelock(address _newTimelock) external onlyByOwnGov {\n        timelock = _newTimelock;\n    }\n}\n"
    },
    "contracts/automation/Resolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../access/Owned.sol\";\nimport \"../interfaces/apps/IVeUnoDaoYieldDistributor.sol\";\n\ncontract Resolver is Owned {\n    event ApyUpdated(uint256 apy);\n\n    uint256 public constant APY_BASE = 10000; // APY should be provided as per this base to get ratio, 60% should 6000\n    uint256 public constant SECONDS_IN_YEAR = 31536000;\n\n    IVeUnoDaoYieldDistributor public immutable yieldDistributor;\n    IERC20 public immutable veUno;\n\n    uint256 public apy;\n    address public rewardTreasury;\n\n    constructor(\n        IVeUnoDaoYieldDistributor _yieldDistributor,\n        IERC20 _veUno,\n        address _admin,\n        address _rewardTreasury\n    ) Owned(_admin) {\n        yieldDistributor = _yieldDistributor;\n        veUno = _veUno;\n        rewardTreasury = _rewardTreasury;\n    }\n\n    function updateApy(uint256 _apy) external onlyOwner {\n        require(_apy <= APY_BASE, \"NotifyRewardProxy: invalid APY\");\n        apy = _apy;\n        emit ApyUpdated(_apy);\n    }\n\n    function getRewardAmount() public view returns (uint256) {\n        uint256 veTotalSupply = veUno.totalSupply();\n        uint256 duration = yieldDistributor.yieldDuration();\n        uint256 reward = (veTotalSupply * apy * duration) /\n            (APY_BASE * SECONDS_IN_YEAR);\n\n        uint256 periodFinish = yieldDistributor.periodFinish();\n        if (periodFinish > block.timestamp) {\n            periodFinish -= block.timestamp;\n            uint256 yieldRate = yieldDistributor.yieldRate();\n            uint256 leftover = periodFinish * yieldRate;\n\n            if (leftover > reward) {\n                return 0;\n            }\n            reward -= leftover;\n        }\n        return reward;\n    }\n\n    function checker()\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        uint lastChecked = yieldDistributor.lastUpdateTime();\n        if (block.timestamp >= lastChecked + 7 days) {\n            uint256 amount = getRewardAmount();\n            bytes4 selector = bytes4(\n                keccak256(\"notifyRewardAmount(address,uint256)\")\n            );\n            execPayload = abi.encodeWithSelector(\n                selector,\n                rewardTreasury,\n                amount\n            );\n            canExec = true;\n            return (canExec, execPayload);\n        }\n    }\n}\n"
    },
    "contracts/governance/Executor.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity =0.8.23;\n\nimport {ExecutorWithTimelock} from './ExecutorWithTimelock.sol';\nimport {ProposalValidator} from './ProposalValidator.sol';\n\n/**\n * @title Time Locked, Validator, Executor Contract\n * @dev Contract\n * - Validate Proposal creations/ cancellation\n * - Validate Vote Quorum and Vote success on proposal\n * - Queue, Execute, Cancel, successful proposals' transactions.\n **/\ncontract Executor is ExecutorWithTimelock, ProposalValidator {\n  constructor(\n    address admin,\n    uint256 delay,\n    uint256 gracePeriod,\n    uint256 minimumDelay,\n    uint256 maximumDelay,\n    uint256 propositionThreshold,\n    uint256 voteDuration,\n    uint256 voteDifferential,\n    uint256 minimumQuorum\n  )\n    ExecutorWithTimelock(admin, delay, gracePeriod, minimumDelay, maximumDelay)\n    ProposalValidator(propositionThreshold, voteDuration, voteDifferential, minimumQuorum)\n  {}\n}\n"
    },
    "contracts/governance/ExecutorWithTimelock.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity =0.8.23;\n\nimport {IExecutorWithTimelock} from '../interfaces/IExecutorWithTimelock.sol';\nimport {IGovernance} from '../interfaces/IGovernance.sol';\n\n/**\n * @title Time Locked Executor Contract, inherited by Governance Executors\n * @dev Contract that can queue, execute, cancel transactions voted by Governance\n * Queued transactions can be executed after a delay and until\n * Grace period is not over.\n **/\ncontract ExecutorWithTimelock is IExecutorWithTimelock {\n\n  uint256 public immutable override GRACE_PERIOD;\n  uint256 public immutable override MINIMUM_DELAY;\n  uint256 public immutable override MAXIMUM_DELAY;\n\n  address private _admin;\n  address private _pendingAdmin;\n  uint256 private _delay;\n\n  mapping(bytes32 => bool) private _queuedTransactions;\n\n  /**\n   * @dev Constructor\n   * @param admin admin address, that can call the main functions, (Governance)\n   * @param delay minimum time between queueing and execution of proposal\n   * @param gracePeriod time after `delay` while a proposal can be executed\n   * @param minimumDelay lower threshold of `delay`, in seconds\n   * @param maximumDelay upper threhold of `delay`, in seconds\n   **/\n  constructor(\n    address admin,\n    uint256 delay,\n    uint256 gracePeriod,\n    uint256 minimumDelay,\n    uint256 maximumDelay\n  ) {\n    require(delay >= minimumDelay, 'DELAY_SHORTER_THAN_MINIMUM');\n    require(delay <= maximumDelay, 'DELAY_LONGER_THAN_MAXIMUM');\n    _delay = delay;\n    _admin = admin;\n\n    GRACE_PERIOD = gracePeriod;\n    MINIMUM_DELAY = minimumDelay;\n    MAXIMUM_DELAY = maximumDelay;\n\n    emit NewDelay(delay);\n    emit NewAdmin(admin);\n  }\n\n  modifier onlyAdmin() {\n    require(msg.sender == _admin, 'ONLY_BY_ADMIN');\n    _;\n  }\n\n  modifier onlyTimelock() {\n    require(msg.sender == address(this), 'ONLY_BY_THIS_TIMELOCK');\n    _;\n  }\n\n  modifier onlyPendingAdmin() {\n    require(msg.sender == _pendingAdmin, 'ONLY_BY_PENDING_ADMIN');\n    _;\n  }\n\n  /**\n   * @dev Set the delay\n   * @param delay delay between queue and execution of proposal\n   **/\n  function setDelay(uint256 delay) public onlyTimelock {\n    _validateDelay(delay);\n    _delay = delay;\n\n    emit NewDelay(delay);\n  }\n\n  /**\n   * @dev Function enabling pending admin to become admin\n   **/\n  function acceptAdmin() public onlyPendingAdmin {\n    _admin = msg.sender;\n    _pendingAdmin = address(0);\n\n    emit NewAdmin(msg.sender);\n  }\n\n  /**\n   * @dev Setting a new pending admin (that can then become admin)\n   * Can only be called by this executor (i.e via proposal)\n   * @param newPendingAdmin address of the new admin\n   **/\n  function setPendingAdmin(address newPendingAdmin) public onlyTimelock {\n    _pendingAdmin = newPendingAdmin;\n\n    emit NewPendingAdmin(newPendingAdmin);\n  }\n\n  /**\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\n   * @param target smart contract target\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param executionTime time at which to execute the transaction\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   * @return the action Hash\n   **/\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) public override onlyAdmin returns (bytes32) {\n    require(executionTime >= block.timestamp + _delay, 'EXECUTION_TIME_UNDERESTIMATED');\n\n    bytes32 actionHash = keccak256(\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\n    );\n    _queuedTransactions[actionHash] = true;\n\n    emit QueuedAction(actionHash, target, value, signature, data, executionTime, withDelegatecall);\n    return actionHash;\n  }\n\n  /**\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\n   * @param target smart contract target\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param executionTime time at which to execute the transaction\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   * @return the action Hash of the canceled tx\n   **/\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) public override onlyAdmin returns (bytes32) {\n    bytes32 actionHash = keccak256(\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\n    );\n    _queuedTransactions[actionHash] = false;\n\n    emit CancelledAction(\n      actionHash,\n      target,\n      value,\n      signature,\n      data,\n      executionTime,\n      withDelegatecall\n    );\n    return actionHash;\n  }\n\n  /**\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\n   * @param target smart contract target\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param executionTime time at which to execute the transaction\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   * @return the callData executed as memory bytes\n   **/\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) public payable override onlyAdmin returns (bytes memory) {\n    bytes32 actionHash = keccak256(\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\n    );\n    require(_queuedTransactions[actionHash], 'ACTION_NOT_QUEUED');\n    require(block.timestamp >= executionTime, 'TIMELOCK_NOT_FINISHED');\n    require(block.timestamp <= executionTime + GRACE_PERIOD, 'GRACE_PERIOD_FINISHED');\n\n    _queuedTransactions[actionHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    bool success;\n    bytes memory resultData;\n    if (withDelegatecall) {\n      require(msg.value >= value, \"NOT_ENOUGH_MSG_VALUE\");\n      // solium-disable-next-line security/no-call-value\n      (success, resultData) = target.delegatecall(callData);\n    } else {\n      // solium-disable-next-line security/no-call-value\n      (success, resultData) = target.call{value: value}(callData);\n    }\n\n    require(success, 'FAILED_ACTION_EXECUTION');\n\n    emit ExecutedAction(\n      actionHash,\n      target,\n      value,\n      signature,\n      data,\n      executionTime,\n      withDelegatecall,\n      resultData\n    );\n\n    return resultData;\n  }\n\n  /**\n   * @dev Getter of the current admin address (should be governance)\n   * @return The address of the current admin\n   **/\n  function getAdmin() external view override returns (address) {\n    return _admin;\n  }\n\n  /**\n   * @dev Getter of the current pending admin address\n   * @return The address of the pending admin\n   **/\n  function getPendingAdmin() external view override returns (address) {\n    return _pendingAdmin;\n  }\n\n  /**\n   * @dev Getter of the delay between queuing and execution\n   * @return The delay in seconds\n   **/\n  function getDelay() external view override returns (uint256) {\n    return _delay;\n  }\n\n  /**\n   * @dev Returns whether an action (via actionHash) is queued\n   * @param actionHash hash of the action to be checked\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\n   * @return true if underlying action of actionHash is queued\n   **/\n  function isActionQueued(bytes32 actionHash) external view override returns (bool) {\n    return _queuedTransactions[actionHash];\n  }\n\n  /**\n   * @dev Checks whether a proposal is over its grace period\n   * @param governance Governance contract\n   * @param proposalId Id of the proposal against which to test\n   * @return true of proposal is over grace period\n   **/\n  function isProposalOverGracePeriod(IGovernance governance, uint256 proposalId)\n    external\n    view\n    override\n    returns (bool)\n  {\n    IGovernance.ProposalWithoutVotes memory proposal = governance.getProposalById(proposalId);\n\n    return (block.timestamp > proposal.executionTime + GRACE_PERIOD);\n  }\n\n  function _validateDelay(uint256 delay) internal view {\n    require(delay >= MINIMUM_DELAY, 'DELAY_SHORTER_THAN_MINIMUM');\n    require(delay <= MAXIMUM_DELAY, 'DELAY_LONGER_THAN_MAXIMUM');\n  }\n\n  receive() external payable {}\n}\n"
    },
    "contracts/governance/Governance.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity =0.8.23;\n\nimport {IVotingStrategy} from '../interfaces/IVotingStrategy.sol';\nimport {IExecutorWithTimelock} from '../interfaces/IExecutorWithTimelock.sol';\nimport {IProposalValidator} from '../interfaces/IProposalValidator.sol';\nimport {IGovernance} from '../interfaces/IGovernance.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {getChainId} from '../misc/Helpers.sol';\n\n/**\n * @title Governance contract\n * @dev Main point of interaction with protocol's governance\n * - Create a Proposal\n * - Cancel a Proposal\n * - Queue a Proposal\n * - Execute a Proposal\n * - Submit Vote to a Proposal\n * Proposal States : Pending => Active => Succeeded(/Failed) => Queued => Executed(/Expired)\n *                   The transition to \"Canceled\" can appear in multiple states\n **/\ncontract Governance is Ownable, IGovernance {\n\n  address private _governanceStrategy;\n  uint256 private _votingDelay;\n\n  uint256 private _proposalsCount;\n  mapping(uint256 => Proposal) private _proposals;\n  mapping(address => bool) private _authorizedExecutors;\n\n  address private _guardian;\n\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\n    'EIP712Domain(string name,uint256 chainId,address verifyingContract)'\n  );\n  bytes32 public constant VOTE_EMITTED_TYPEHASH = keccak256('VoteEmitted(uint256 id,bool support)');\n  string public constant NAME = 'Governance';\n\n  modifier onlyGuardian() {\n    require(msg.sender == _guardian, 'ONLY_BY_GUARDIAN');\n    _;\n  }\n\n  constructor(\n    address governanceStrategy,\n    uint256 votingDelay,\n    address guardian,\n    address[] memory executors\n  ) Ownable(msg.sender) {\n    _setGovernanceStrategy(governanceStrategy);\n    _setVotingDelay(votingDelay);\n    _guardian = guardian;\n\n    authorizeExecutors(executors);\n  }\n\n  struct CreateVars {\n    uint256 startBlock;\n    uint256 endBlock;\n    uint256 previousProposalsCount;\n  }\n\n  /**\n   * @dev Creates a Proposal (needs to be validated by the Proposal Validator)\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\n   * @param targets list of contracts called by proposal's associated transactions\n   * @param values list of value in wei for each propoposal's associated transaction\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\n   * @param ipfsHash IPFS hash of the proposal\n   **/\n  function create(\n    IExecutorWithTimelock executor,\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    bool[] memory withDelegatecalls,\n    bytes32 ipfsHash\n  ) external override returns (uint256) {\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\n    require(\n      targets.length == values.length &&\n        targets.length == signatures.length &&\n        targets.length == calldatas.length &&\n        targets.length == withDelegatecalls.length,\n      'INCONSISTENT_PARAMS_LENGTH'\n    );\n\n    require(isExecutorAuthorized(address(executor)), 'EXECUTOR_NOT_AUTHORIZED');\n\n    require(\n      IProposalValidator(address(executor)).validateCreatorOfProposal(\n        this,\n        msg.sender,\n        block.number - 1\n      ),\n      'PROPOSITION_CREATION_INVALID'\n    );\n\n    CreateVars memory vars;\n\n    vars.startBlock = block.number + _votingDelay;\n    vars.endBlock = vars.startBlock + (IProposalValidator(address(executor)).VOTING_DURATION());\n\n    vars.previousProposalsCount = _proposalsCount;\n\n    Proposal storage newProposal = _proposals[vars.previousProposalsCount];\n    newProposal.id = vars.previousProposalsCount;\n    newProposal.creator = msg.sender;\n    newProposal.executor = executor;\n    newProposal.targets = targets;\n    newProposal.values = values;\n    newProposal.signatures = signatures;\n    newProposal.calldatas = calldatas;\n    newProposal.withDelegatecalls = withDelegatecalls;\n    newProposal.startBlock = vars.startBlock;\n    newProposal.endBlock = vars.endBlock;\n    newProposal.strategy = _governanceStrategy;\n    newProposal.ipfsHash = ipfsHash;\n    _proposalsCount++;\n\n    emit ProposalCreated(\n      vars.previousProposalsCount,\n      msg.sender,\n      executor,\n      targets,\n      values,\n      signatures,\n      calldatas,\n      withDelegatecalls,\n      vars.startBlock,\n      vars.endBlock,\n      _governanceStrategy,\n      ipfsHash\n    );\n\n    return newProposal.id;\n  }\n\n  /**\n   * @dev Cancels a Proposal.\n   * - Callable by the _guardian with relaxed conditions, or by anybody if the conditions of\n   *   cancellation on the executor are fulfilled\n   * @param proposalId id of the proposal\n   **/\n  function cancel(uint256 proposalId) external override {\n    ProposalState state = getProposalState(proposalId);\n    require(\n      state != ProposalState.Executed &&\n        state != ProposalState.Canceled &&\n        state != ProposalState.Expired,\n      'ONLY_BEFORE_EXECUTED'\n    );\n\n    Proposal storage proposal = _proposals[proposalId];\n    require(\n      msg.sender == _guardian ||\n        IProposalValidator(address(proposal.executor)).validateProposalCancellation(\n          this,\n          proposal.creator,\n          block.number - 1\n        ),\n      'PROPOSITION_CANCELLATION_INVALID'\n    );\n    proposal.canceled = true;\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      proposal.executor.cancelTransaction(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.executionTime,\n        proposal.withDelegatecalls[i]\n      );\n    }\n\n    emit ProposalCanceled(proposalId);\n  }\n\n  /**\n   * @dev Queue the proposal (If Proposal Succeeded)\n   * @param proposalId id of the proposal to queue\n   **/\n  function queue(uint256 proposalId) external override {\n    require(getProposalState(proposalId) == ProposalState.Succeeded, 'INVALID_STATE_FOR_QUEUE');\n    Proposal storage proposal = _proposals[proposalId];\n    uint256 executionTime = block.timestamp + (proposal.executor.getDelay());\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      _queueOrRevert(\n        proposal.executor,\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        executionTime,\n        proposal.withDelegatecalls[i]\n      );\n    }\n    proposal.executionTime = executionTime;\n\n    emit ProposalQueued(proposalId, executionTime, msg.sender);\n  }\n\n  /**\n   * @dev Execute the proposal (If Proposal Queued)\n   * @param proposalId id of the proposal to execute\n   **/\n  function execute(uint256 proposalId) external payable override {\n    require(getProposalState(proposalId) == ProposalState.Queued, 'ONLY_QUEUED_PROPOSALS');\n    Proposal storage proposal = _proposals[proposalId];\n    proposal.executed = true;\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      proposal.executor.executeTransaction{value: proposal.values[i]}(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.executionTime,\n        proposal.withDelegatecalls[i]\n      );\n    }\n    emit ProposalExecuted(proposalId, msg.sender);\n  }\n\n  /**\n   * @dev Function allowing msg.sender to vote for/against a proposal\n   * @param proposalId id of the proposal\n   * @param support boolean, true = vote for, false = vote against\n   **/\n  function submitVote(uint256 proposalId, bool support) external override {\n    return _submitVote(msg.sender, proposalId, support);\n  }\n\n  /**\n   * @dev Function to register the vote of user that has voted offchain via signature\n   * @param proposalId id of the proposal\n   * @param support boolean, true = vote for, false = vote against\n   * @param v v part of the voter signature\n   * @param r r part of the voter signature\n   * @param s s part of the voter signature\n   **/\n  function submitVoteBySignature(\n    uint256 proposalId,\n    bool support,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override {\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        '\\x19\\x01',\n        keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainId(), address(this))),\n        keccak256(abi.encode(VOTE_EMITTED_TYPEHASH, proposalId, support))\n      )\n    );\n    address signer = ecrecover(digest, v, r, s);\n    require(signer != address(0), 'INVALID_SIGNATURE');\n    return _submitVote(signer, proposalId, support);\n  }\n\n  /**\n   * @dev Set new GovernanceStrategy\n   * Note: owner should be a timelocked executor, so needs to make a proposal\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\n   **/\n  function setGovernanceStrategy(address governanceStrategy) external override onlyOwner {\n    _setGovernanceStrategy(governanceStrategy);\n  }\n\n  /**\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\n   * Note: owner should be a timelocked executor, so needs to make a proposal\n   * @param votingDelay new voting delay in terms of blocks\n   **/\n  function setVotingDelay(uint256 votingDelay) external override onlyOwner {\n    _setVotingDelay(votingDelay);\n  }\n\n  /**\n   * @dev Add new addresses to the list of authorized executors\n   * @param executors list of new addresses to be authorized executors\n   **/\n  function authorizeExecutors(address[] memory executors) public override onlyOwner {\n    for (uint256 i = 0; i < executors.length; i++) {\n      _authorizeExecutor(executors[i]);\n    }\n  }\n\n  /**\n   * @dev Remove addresses to the list of authorized executors\n   * @param executors list of addresses to be removed as authorized executors\n   **/\n  function unauthorizeExecutors(address[] memory executors) public override onlyOwner {\n    for (uint256 i = 0; i < executors.length; i++) {\n      _unauthorizeExecutor(executors[i]);\n    }\n  }\n\n  /**\n   * @dev Let the guardian abdicate from its priviledged rights\n   **/\n  function __abdicate() external override onlyGuardian {\n    _guardian = address(0);\n  }\n\n  /**\n   * @dev Getter of the current GovernanceStrategy address\n   * @return The address of the current GovernanceStrategy contracts\n   **/\n  function getGovernanceStrategy() external view override returns (address) {\n    return _governanceStrategy;\n  }\n\n  /**\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\n   * Different from the voting duration\n   * @return The voting delay in number of blocks\n   **/\n  function getVotingDelay() external view override returns (uint256) {\n    return _votingDelay;\n  }\n\n  /**\n   * @dev Returns whether an address is an authorized executor\n   * @param executor address to evaluate as authorized executor\n   * @return true if authorized\n   **/\n  function isExecutorAuthorized(address executor) public view override returns (bool) {\n    return _authorizedExecutors[executor];\n  }\n\n  /**\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\n   * @return The address of the guardian\n   **/\n  function getGuardian() external view override returns (address) {\n    return _guardian;\n  }\n\n  /**\n   * @dev Getter of the proposal count (the current number of proposals ever created)\n   * @return the proposal count\n   **/\n  function getProposalsCount() external view override returns (uint256) {\n    return _proposalsCount;\n  }\n\n  /**\n   * @dev Getter of a proposal by id\n   * @param proposalId id of the proposal to get\n   * @return the proposal as ProposalWithoutVotes memory object\n   **/\n  function getProposalById(uint256 proposalId)\n    external\n    view\n    override\n    returns (ProposalWithoutVotes memory)\n  {\n    Proposal storage proposal = _proposals[proposalId];\n    ProposalWithoutVotes memory proposalWithoutVotes = ProposalWithoutVotes({\n      id: proposal.id,\n      creator: proposal.creator,\n      executor: proposal.executor,\n      targets: proposal.targets,\n      values: proposal.values,\n      signatures: proposal.signatures,\n      calldatas: proposal.calldatas,\n      withDelegatecalls: proposal.withDelegatecalls,\n      startBlock: proposal.startBlock,\n      endBlock: proposal.endBlock,\n      executionTime: proposal.executionTime,\n      forVotes: proposal.forVotes,\n      againstVotes: proposal.againstVotes,\n      executed: proposal.executed,\n      canceled: proposal.canceled,\n      strategy: proposal.strategy,\n      ipfsHash: proposal.ipfsHash\n    });\n\n    return proposalWithoutVotes;\n  }\n\n  /**\n   * @dev Getter of the Vote of a voter about a proposal\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\n   * @param proposalId id of the proposal\n   * @param voter address of the voter\n   * @return The associated Vote memory object\n   **/\n  function getVoteOnProposal(uint256 proposalId, address voter)\n    external\n    view\n    override\n    returns (Vote memory)\n  {\n    return _proposals[proposalId].votes[voter];\n  }\n\n  /**\n   * @dev Get the current state of a proposal\n   * @param proposalId id of the proposal\n   * @return The current state if the proposal\n   **/\n  function getProposalState(uint256 proposalId) public view override returns (ProposalState) {\n    require(_proposalsCount >= proposalId, 'INVALID_PROPOSAL_ID');\n    Proposal storage proposal = _proposals[proposalId];\n    if (proposal.canceled) {\n      return ProposalState.Canceled;\n    } else if (block.number <= proposal.startBlock) {\n      return ProposalState.Pending;\n    } else if (block.number <= proposal.endBlock) {\n      return ProposalState.Active;\n    } else if (!IProposalValidator(address(proposal.executor)).isProposalPassed(this, proposalId)) {\n      return ProposalState.Failed;\n    } else if (proposal.executionTime == 0) {\n      return ProposalState.Succeeded;\n    } else if (proposal.executed) {\n      return ProposalState.Executed;\n    } else if (proposal.executor.isProposalOverGracePeriod(this, proposalId)) {\n      return ProposalState.Expired;\n    } else {\n      return ProposalState.Queued;\n    }\n  }\n\n  function _queueOrRevert(\n    IExecutorWithTimelock executor,\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory callData,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) internal {\n    require(\n      !executor.isActionQueued(\n        keccak256(abi.encode(target, value, signature, callData, executionTime, withDelegatecall))\n      ),\n      'DUPLICATED_ACTION'\n    );\n    executor.queueTransaction(target, value, signature, callData, executionTime, withDelegatecall);\n  }\n\n  function _submitVote(\n    address voter,\n    uint256 proposalId,\n    bool support\n  ) internal {\n    require(getProposalState(proposalId) == ProposalState.Active, 'VOTING_CLOSED');\n    Proposal storage proposal = _proposals[proposalId];\n    Vote storage vote = proposal.votes[voter];\n\n    require(vote.votingPower == 0, 'VOTE_ALREADY_SUBMITTED');\n\n    uint256 votingPower = IVotingStrategy(proposal.strategy).getVotingPowerAt(\n      voter,\n      proposal.startBlock\n    );\n\n    if (support) {\n      proposal.forVotes = proposal.forVotes + votingPower;\n    } else {\n      proposal.againstVotes = proposal.againstVotes + votingPower;\n    }\n\n    vote.support = support;\n    vote.votingPower = uint248(votingPower);\n\n    emit VoteEmitted(proposalId, voter, support, votingPower);\n  }\n\n  function _setGovernanceStrategy(address governanceStrategy) internal {\n    _governanceStrategy = governanceStrategy;\n\n    emit GovernanceStrategyChanged(governanceStrategy, msg.sender);\n  }\n\n  function _setVotingDelay(uint256 votingDelay) internal {\n    _votingDelay = votingDelay;\n\n    emit VotingDelayChanged(votingDelay, msg.sender);\n  }\n\n  function _authorizeExecutor(address executor) internal {\n    _authorizedExecutors[executor] = true;\n    emit ExecutorAuthorized(executor);\n  }\n\n  function _unauthorizeExecutor(address executor) internal {\n    _authorizedExecutors[executor] = false;\n    emit ExecutorUnauthorized(executor);\n  }\n}\n"
    },
    "contracts/governance/GovernanceStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity =0.8.23;\n\nimport {IGovernanceStrategy} from '../interfaces/IGovernanceStrategy.sol';\nimport {IERC20} from '../interfaces/IERC20.sol';\nimport {IGovernancePowerDelegationToken} from '../interfaces/IGovernancePowerDelegationToken.sol';\n\n/**\n * @title Governance Strategy contract\n * @dev Smart contract containing logic to measure users' relative power to propose and vote.\n * User Power = User Power from Uno token + User Power from stkUno Token.\n * User Power from Token = Token Power + Token Power as Delegatee [- Token Power if user has delegated]\n * Two wrapper functions linked to Uno Tokens's GovernancePowerDelegationERC20.sol implementation\n * - getPropositionPowerAt: fetching a user Proposition Power at a specified block\n * - getVotingPowerAt: fetching a user Voting Power at a specified block\n **/\ncontract GovernanceStrategy is IGovernanceStrategy {\n  address public immutable UNO;\n  address public immutable STK_UNO;\n\n  /**\n   * @dev Constructor, register tokens used for Voting and Proposition Powers.\n   * @param _uno The address of the UNO Token contract.\n   * @param _stkUNO The address of the stkUNO Token Contract\n   **/\n  constructor(address _uno, address _stkUNO) {\n    UNO = _uno;\n    STK_UNO = _stkUNO;\n  }\n\n  /**\n   * @dev Returns the total supply of Proposition Tokens Available for Governance\n   * = UNO Available for governance      + stkUNO available\n   * The supply of UNO staked in stkUNO are not taken into account so:\n   * = (Supply of UNO - UNO in stkUNO) + (Supply of stkUNO)\n   * = Supply of UNO, Since the supply of stkUNO is equal to the number of UNO staked\n   * @param blockNumber Blocknumber at which to evaluate\n   * @return total supply at blockNumber\n   **/\n  function getTotalPropositionSupplyAt(uint256 blockNumber) public view override returns (uint256) {\n    return IERC20(UNO).totalSupplyAt(blockNumber);\n  }\n\n  /**\n   * @dev Returns the total supply of Outstanding Voting Tokens \n   * @param blockNumber Blocknumber at which to evaluate\n   * @return total supply at blockNumber\n   **/\n  function getTotalVotingSupplyAt(uint256 blockNumber) public view override returns (uint256) {\n    return getTotalPropositionSupplyAt(blockNumber);\n  }\n\n  /**\n   * @dev Returns the Proposition Power of a user at a specific block number.\n   * @param user Address of the user.\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\n   * @return Power number\n   **/\n  function getPropositionPowerAt(address user, uint256 blockNumber)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _getPowerByTypeAt(user, blockNumber, IGovernancePowerDelegationToken.DelegationType.PROPOSITION_POWER);\n  }\n\n  /**\n   * @dev Returns the Vote Power of a user at a specific block number.\n   * @param user Address of the user.\n   * @param blockNumber Blocknumber at which to fetch Vote Power\n   * @return Vote number\n   **/\n  function getVotingPowerAt(address user, uint256 blockNumber)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return _getPowerByTypeAt(user, blockNumber, IGovernancePowerDelegationToken.DelegationType.VOTING_POWER);\n  }\n\n  function _getPowerByTypeAt(\n    address user,\n    uint256 blockNumber,\n    IGovernancePowerDelegationToken.DelegationType powerType\n  ) internal view returns (uint256) {\n    return\n      IGovernancePowerDelegationToken(UNO).getPowerAtBlock(user, blockNumber, powerType) +\n      IGovernancePowerDelegationToken(STK_UNO).getPowerAtBlock(user, blockNumber, powerType);\n  }\n}\n"
    },
    "contracts/governance/ProposalValidator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity =0.8.23;\n\nimport {IGovernance} from '../interfaces/IGovernance.sol';\nimport {IGovernanceStrategy} from '../interfaces/IGovernanceStrategy.sol';\nimport {IProposalValidator} from '../interfaces/IProposalValidator.sol';\n\n/**\n * @title Proposal Validator Contract, inherited by Governance Executors\n * @dev Validates/Invalidations propositions state modifications.\n * Proposition Power functions: Validates proposition creations/ cancellation\n * Voting Power functions: Validates success of propositions.\n **/\ncontract ProposalValidator is IProposalValidator {\n\n  uint256 public immutable override PROPOSITION_THRESHOLD;\n  uint256 public immutable override VOTING_DURATION;\n  uint256 public immutable override VOTE_DIFFERENTIAL;\n  uint256 public immutable override MINIMUM_QUORUM;\n  uint256 public constant override ONE_HUNDRED_WITH_PRECISION = 10000; // Equivalent to 100%, but scaled for precision\n\n  /**\n   * @dev Constructor\n   * @param propositionThreshold minimum percentage of supply needed to submit a proposal\n   * - In ONE_HUNDRED_WITH_PRECISION units\n   * @param votingDuration duration in blocks of the voting period\n   * @param voteDifferential percentage of supply that `for` votes need to be over `against`\n   *   in order for the proposal to pass\n   * - In ONE_HUNDRED_WITH_PRECISION units\n   * @param minimumQuorum minimum percentage of the supply in FOR-voting-power need for a proposal to pass\n   * - In ONE_HUNDRED_WITH_PRECISION units\n   **/\n  constructor(\n    uint256 propositionThreshold,\n    uint256 votingDuration,\n    uint256 voteDifferential,\n    uint256 minimumQuorum\n  ) {\n    PROPOSITION_THRESHOLD = propositionThreshold;\n    VOTING_DURATION = votingDuration;\n    VOTE_DIFFERENTIAL = voteDifferential;\n    MINIMUM_QUORUM = minimumQuorum;\n  }\n\n  /**\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\n   * @param governance Governance Contract\n   * @param user Address of the proposal creator\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\n   * @return boolean, true if can be created\n   **/\n  function validateCreatorOfProposal(\n    IGovernance governance,\n    address user,\n    uint256 blockNumber\n  ) external view override returns (bool) {\n    return isPropositionPowerEnough(governance, user, blockNumber);\n  }\n\n  /**\n   * @dev Called to validate the cancellation of a proposal\n   * Needs to creator to have lost proposition power threashold\n   * @param governance Governance Contract\n   * @param user Address of the proposal creator\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\n   * @return boolean, true if can be cancelled\n   **/\n  function validateProposalCancellation(\n    IGovernance governance,\n    address user,\n    uint256 blockNumber\n  ) external view override returns (bool) {\n    return !isPropositionPowerEnough(governance, user, blockNumber);\n  }\n\n  /**\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\n   * @param governance Governance Contract\n   * @param user Address of the user to be challenged.\n   * @param blockNumber Block Number against which to make the challenge.\n   * @return true if user has enough power\n   **/\n  function isPropositionPowerEnough(\n    IGovernance governance,\n    address user,\n    uint256 blockNumber\n  ) public view override returns (bool) {\n    IGovernanceStrategy currentGovernanceStrategy = IGovernanceStrategy(\n      governance.getGovernanceStrategy()\n    );\n    return\n      currentGovernanceStrategy.getPropositionPowerAt(user, blockNumber) >=\n      getMinimumPropositionPowerNeeded(governance, blockNumber);\n  }\n\n  /**\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\n   * @param governance Governance Contract\n   * @param blockNumber Blocknumber at which to evaluate\n   * @return minimum Proposition Power needed\n   **/\n  function getMinimumPropositionPowerNeeded(IGovernance governance, uint256 blockNumber)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    IGovernanceStrategy currentGovernanceStrategy = IGovernanceStrategy(\n      governance.getGovernanceStrategy()\n    );\n    return\n      (currentGovernanceStrategy\n        .getTotalPropositionSupplyAt(blockNumber)\n         * PROPOSITION_THRESHOLD) / \n        ONE_HUNDRED_WITH_PRECISION;\n  }\n\n  /**\n   * @dev Returns whether a proposal passed or not\n   * @param governance Governance Contract\n   * @param proposalId Id of the proposal to set\n   * @return true if proposal passed\n   **/\n  function isProposalPassed(IGovernance governance, uint256 proposalId)\n    external\n    view\n    override\n    returns (bool)\n  {\n    return (isQuorumValid(governance, proposalId) &&\n      isVoteDifferentialValid(governance, proposalId));\n  }\n\n  /**\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\n   * @param votingSupply Total number of oustanding voting tokens\n   * @return voting power needed for a proposal to pass\n   **/\n  function getMinimumVotingPowerNeeded(uint256 votingSupply)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return (votingSupply * MINIMUM_QUORUM) / ONE_HUNDRED_WITH_PRECISION;\n  }\n\n  /**\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\n   * @param governance Governance Contract\n   * @param proposalId Id of the proposal to verify\n   * @return voting power needed for a proposal to pass\n   **/\n  function isQuorumValid(IGovernance governance, uint256 proposalId)\n    public\n    view\n    override\n    returns (bool)\n  {\n    IGovernance.ProposalWithoutVotes memory proposal = governance.getProposalById(proposalId);\n    uint256 votingSupply = IGovernanceStrategy(proposal.strategy).getTotalVotingSupplyAt(\n      proposal.startBlock\n    );\n\n    return proposal.forVotes >= getMinimumVotingPowerNeeded(votingSupply);\n  }\n\n  /**\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\n   * @param governance Governance Contract\n   * @param proposalId Id of the proposal to verify\n   * @return true if enough For-Votes\n   **/\n  function isVoteDifferentialValid(IGovernance governance, uint256 proposalId)\n    public\n    view\n    override\n    returns (bool)\n  {\n    IGovernance.ProposalWithoutVotes memory proposal = governance.getProposalById(proposalId);\n    uint256 votingSupply = IGovernanceStrategy(proposal.strategy).getTotalVotingSupplyAt(\n      proposal.startBlock\n    );\n\n    return (((proposal.forVotes * ONE_HUNDRED_WITH_PRECISION) / votingSupply) >\n      ((proposal.againstVotes * ONE_HUNDRED_WITH_PRECISION) / votingSupply) + (\n        VOTE_DIFFERENTIAL\n      ));\n  }\n}\n"
    },
    "contracts/interfaces/apps/IVeUnoDaoYieldDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IVeUnoDaoYieldDistributor {\n    function notifyRewardAmount(uint256 amount) external;\n\n    function yieldDuration() external view returns (uint256);\n\n    function periodFinish() external view returns (uint256);\n\n    function yieldRate() external view returns (uint256);\n\n    function lastUpdateTime() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/dao/ISmartWalletChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.23;\n\ninterface ISmartWalletChecker {\n    function check(address _addr) external returns (bool);\n}\n"
    },
    "contracts/interfaces/dao/IVotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.23;\n\ninterface IVotingEscrow {\n    struct LockedBalance {\n        int256 amount;\n        uint256 end;\n    }\n\n    function get_last_user_slope(address _addr) external view returns (uint256);\n\n    function locked__end(address _addr) external view returns (uint256);\n\n    // function balanceOf(address _addr, uint256 _t) external view returns (uint256);\n    function balanceOf(address addr)external view returns (uint256);\n\n    // function totalSupply(uint256 _t) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n\n    function locked (address arg0) external view returns ( LockedBalance memory );\n\n    function get_user_point_epoch(address _user)\n        external\n        view\n        returns (uint256);\n\n    function user_point_history__ts(address _addr, uint256 _idx)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity =0.8.23;\n\ninterface IERC20 {\n  function totalSupplyAt(uint256 blockNumber) external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IExecutorWithTimelock.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity =0.8.23;\n\nimport {IGovernance} from './IGovernance.sol';\n\ninterface IExecutorWithTimelock {\n  /**\n   * @dev emitted when a new pending admin is set\n   * @param newPendingAdmin address of the new pending admin\n   **/\n  event NewPendingAdmin(address newPendingAdmin);\n\n  /**\n   * @dev emitted when a new admin is set\n   * @param newAdmin address of the new admin\n   **/\n  event NewAdmin(address newAdmin);\n\n  /**\n   * @dev emitted when a new delay (between queueing and execution) is set\n   * @param delay new delay\n   **/\n  event NewDelay(uint256 delay);\n\n  /**\n   * @dev emitted when a new (trans)action is Queued.\n   * @param actionHash hash of the action\n   * @param target address of the targeted contract\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param executionTime time at which to execute the transaction\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   **/\n  event QueuedAction(\n    bytes32 actionHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 executionTime,\n    bool withDelegatecall\n  );\n\n  /**\n   * @dev emitted when an action is Cancelled\n   * @param actionHash hash of the action\n   * @param target address of the targeted contract\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param executionTime time at which to execute the transaction\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   **/\n  event CancelledAction(\n    bytes32 actionHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 executionTime,\n    bool withDelegatecall\n  );\n\n  /**\n   * @dev emitted when an action is Cancelled\n   * @param actionHash hash of the action\n   * @param target address of the targeted contract\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param executionTime time at which to execute the transaction\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   * @param resultData the actual callData used on the target\n   **/\n  event ExecutedAction(\n    bytes32 actionHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 executionTime,\n    bool withDelegatecall,\n    bytes resultData\n  );\n  /**\n   * @dev Getter of the current admin address (should be governance)\n   * @return The address of the current admin \n   **/\n  function getAdmin() external view returns (address);\n  /**\n   * @dev Getter of the current pending admin address\n   * @return The address of the pending admin \n   **/\n  function getPendingAdmin() external view returns (address);\n  /**\n   * @dev Getter of the delay between queuing and execution\n   * @return The delay in seconds\n   **/\n  function getDelay() external view returns (uint256);\n  /**\n   * @dev Returns whether an action (via actionHash) is queued\n   * @param actionHash hash of the action to be checked\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\n   * @return true if underlying action of actionHash is queued\n   **/\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\n  /**\n   * @dev Checks whether a proposal is over its grace period \n   * @param governance Governance contract\n   * @param proposalId Id of the proposal against which to test\n   * @return true of proposal is over grace period\n   **/\n  function isProposalOverGracePeriod(IGovernance governance, uint256 proposalId)\n    external\n    view\n    returns (bool);\n  /**\n   * @dev Getter of grace period constant\n   * @return grace period in seconds\n   **/\n  function GRACE_PERIOD() external view returns (uint256);\n  /**\n   * @dev Getter of minimum delay constant\n   * @return minimum delay in seconds\n   **/\n  function MINIMUM_DELAY() external view returns (uint256);\n  /**\n   * @dev Getter of maximum delay constant\n   * @return maximum delay in seconds\n   **/\n  function MAXIMUM_DELAY() external view returns (uint256);\n  /**\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\n   * @param target smart contract target\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param executionTime time at which to execute the transaction\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   **/\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) external returns (bytes32);\n  /**\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\n   * @param target smart contract target\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param executionTime time at which to execute the transaction\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   **/\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) external payable returns (bytes memory);\n  /**\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\n   * @param target smart contract target\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param executionTime time at which to execute the transaction\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   **/\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) external returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IGovernance.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity =0.8.23;\n\nimport {IExecutorWithTimelock} from './IExecutorWithTimelock.sol';\n\ninterface IGovernance {\n  enum ProposalState {Pending, Canceled, Active, Failed, Succeeded, Queued, Expired, Executed}\n\n  struct Vote {\n    bool support;\n    uint248 votingPower;\n  }\n\n  struct Proposal {\n    uint256 id;\n    address creator;\n    IExecutorWithTimelock executor;\n    address[] targets;\n    uint256[] values;\n    string[] signatures;\n    bytes[] calldatas;\n    bool[] withDelegatecalls;\n    uint256 startBlock;\n    uint256 endBlock;\n    uint256 executionTime;\n    uint256 forVotes;\n    uint256 againstVotes;\n    bool executed;\n    bool canceled;\n    address strategy;\n    bytes32 ipfsHash;\n    mapping(address => Vote) votes;\n  }\n\n  struct ProposalWithoutVotes {\n    uint256 id;\n    address creator;\n    IExecutorWithTimelock executor;\n    address[] targets;\n    uint256[] values;\n    string[] signatures;\n    bytes[] calldatas;\n    bool[] withDelegatecalls;\n    uint256 startBlock;\n    uint256 endBlock;\n    uint256 executionTime;\n    uint256 forVotes;\n    uint256 againstVotes;\n    bool executed;\n    bool canceled;\n    address strategy;\n    bytes32 ipfsHash;\n  }\n\n  /**\n   * @dev emitted when a new proposal is created\n   * @param id Id of the proposal\n   * @param creator address of the creator\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\n   * @param targets list of contracts called by proposal's associated transactions\n   * @param values list of value in wei for each propoposal's associated transaction\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\n   * @param startBlock block number when vote starts\n   * @param endBlock block number when vote ends\n   * @param strategy address of the governanceStrategy contract\n   * @param ipfsHash IPFS hash of the proposal\n   **/\n  event ProposalCreated(\n    uint256 id,\n    address indexed creator,\n    IExecutorWithTimelock indexed executor,\n    address[] targets,\n    uint256[] values,\n    string[] signatures,\n    bytes[] calldatas,\n    bool[] withDelegatecalls,\n    uint256 startBlock,\n    uint256 endBlock,\n    address strategy,\n    bytes32 ipfsHash\n  );\n\n  /**\n   * @dev emitted when a proposal is canceled\n   * @param id Id of the proposal\n   **/\n  event ProposalCanceled(uint256 id);\n\n  /**\n   * @dev emitted when a proposal is queued\n   * @param id Id of the proposal\n   * @param executionTime time when proposal underlying transactions can be executed\n   * @param initiatorQueueing address of the initiator of the queuing transaction\n   **/\n  event ProposalQueued(uint256 id, uint256 executionTime, address indexed initiatorQueueing);\n  /**\n   * @dev emitted when a proposal is executed\n   * @param id Id of the proposal\n   * @param initiatorExecution address of the initiator of the execution transaction\n   **/\n  event ProposalExecuted(uint256 id, address indexed initiatorExecution);\n  /**\n   * @dev emitted when a vote is registered\n   * @param id Id of the proposal\n   * @param voter address of the voter\n   * @param support boolean, true = vote for, false = vote against\n   * @param votingPower Power of the voter/vote\n   **/\n  event VoteEmitted(uint256 id, address indexed voter, bool support, uint256 votingPower);\n\n  event GovernanceStrategyChanged(address indexed newStrategy, address indexed initiatorChange);\n\n  event VotingDelayChanged(uint256 newVotingDelay, address indexed initiatorChange);\n\n  event ExecutorAuthorized(address executor);\n\n  event ExecutorUnauthorized(address executor);\n\n  /**\n   * @dev Creates a Proposal (needs Proposition Power of creator > Threshold)\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\n   * @param targets list of contracts called by proposal's associated transactions\n   * @param values list of value in wei for each propoposal's associated transaction\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\n   * @param withDelegatecalls if true, transaction delegatecalls the taget, else calls the target\n   * @param ipfsHash IPFS hash of the proposal\n   **/\n  function create(\n    IExecutorWithTimelock executor,\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    bool[] memory withDelegatecalls,\n    bytes32 ipfsHash\n  ) external returns (uint256);\n\n  /**\n   * @dev Cancels a Proposal,\n   * either at anytime by guardian\n   * or when proposal is Pending/Active and threshold no longer reached\n   * @param proposalId id of the proposal\n   **/\n  function cancel(uint256 proposalId) external;\n\n  /**\n   * @dev Queue the proposal (If Proposal Succeeded)\n   * @param proposalId id of the proposal to queue\n   **/\n  function queue(uint256 proposalId) external;\n\n  /**\n   * @dev Execute the proposal (If Proposal Queued)\n   * @param proposalId id of the proposal to execute\n   **/\n  function execute(uint256 proposalId) external payable;\n\n  /**\n   * @dev Function allowing msg.sender to vote for/against a proposal\n   * @param proposalId id of the proposal\n   * @param support boolean, true = vote for, false = vote against\n   **/\n  function submitVote(uint256 proposalId, bool support) external;\n\n  /**\n   * @dev Function to register the vote of user that has voted offchain via signature\n   * @param proposalId id of the proposal\n   * @param support boolean, true = vote for, false = vote against\n   * @param v v part of the voter signature\n   * @param r r part of the voter signature\n   * @param s s part of the voter signature\n   **/\n  function submitVoteBySignature(\n    uint256 proposalId,\n    bool support,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Set new GovernanceStrategy\n   * Note: owner should be a timelocked executor, so needs to make a proposal\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\n   **/\n  function setGovernanceStrategy(address governanceStrategy) external;\n\n  /**\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\n   * Note: owner should be a timelocked executor, so needs to make a proposal\n   * @param votingDelay new voting delay in seconds\n   **/\n  function setVotingDelay(uint256 votingDelay) external;\n\n  /**\n   * @dev Add new addresses to the list of authorized executors\n   * @param executors list of new addresses to be authorized executors\n   **/\n  function authorizeExecutors(address[] memory executors) external;\n\n  /**\n   * @dev Remove addresses to the list of authorized executors\n   * @param executors list of addresses to be removed as authorized executors\n   **/\n  function unauthorizeExecutors(address[] memory executors) external;\n\n  /**\n   * @dev Let the guardian abdicate from its priviledged rights\n   **/\n  function __abdicate() external;\n\n  /**\n   * @dev Getter of the current GovernanceStrategy address\n   * @return The address of the current GovernanceStrategy contracts\n   **/\n  function getGovernanceStrategy() external view returns (address);\n\n  /**\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\n   * Different from the voting duration\n   * @return The voting delay in seconds\n   **/\n  function getVotingDelay() external view returns (uint256);\n\n  /**\n   * @dev Returns whether an address is an authorized executor\n   * @param executor address to evaluate as authorized executor\n   * @return true if authorized\n   **/\n  function isExecutorAuthorized(address executor) external view returns (bool);\n\n  /**\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\n   * @return The address of the guardian\n   **/\n  function getGuardian() external view returns (address);\n\n  /**\n   * @dev Getter of the proposal count (the current number of proposals ever created)\n   * @return the proposal count\n   **/\n  function getProposalsCount() external view returns (uint256);\n\n  /**\n   * @dev Getter of a proposal by id\n   * @param proposalId id of the proposal to get\n   * @return the proposal as ProposalWithoutVotes memory object\n   **/\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVotes memory);\n\n  /**\n   * @dev Getter of the Vote of a voter about a proposal\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\n   * @param proposalId id of the proposal\n   * @param voter address of the voter\n   * @return The associated Vote memory object\n   **/\n  function getVoteOnProposal(uint256 proposalId, address voter) external view returns (Vote memory);\n\n  /**\n   * @dev Get the current state of a proposal\n   * @param proposalId id of the proposal\n   * @return The current state if the proposal\n   **/\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\n}\n"
    },
    "contracts/interfaces/IGovernancePowerDelegationToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity =0.8.23;\n\ninterface IGovernancePowerDelegationToken {\n  enum DelegationType {VOTING_POWER, PROPOSITION_POWER}\n\n  /**\n   * @dev returns the delegatee of an user\n   * @param delegator the address of the delegator\n   **/\n  function getDelegateeByType(address delegator, DelegationType delegationType)\n    external\n    view\n    returns (address);\n\n  /**\n   * @dev returns the current delegated power of a user. The current power is the\n   * power delegated at the time of the last snapshot\n   * @param user the user\n   **/\n  function getPowerCurrent(address user, DelegationType delegationType)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev get the power of a user at a specified block\n   * @param user address of the user\n   * @param blockNumber block number at which to get power\n   * @param delegationType delegation type (propose/vote)\n   **/\n  function getPowerAtBlock(\n    address user,\n    uint256 blockNumber,\n    DelegationType delegationType\n  ) external view returns (uint256);\n\n  /**\n   * @dev Delegates power from signatory to `delegatee`\n   * @param delegatee The address to delegate votes to\n   * @param delegationType the type of delegation (VOTING_POWER, PROPOSITION_POWER)\n   * @param nonce The contract state required to match the signature\n   * @param expiry The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   **/\n  function delegateByTypeBySig(\n    address delegatee,\n    DelegationType delegationType,\n    uint256 nonce,\n    uint256 expiry,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Delegates power from signatory to `delegatee`\n   * @param delegatee The address to delegate votes to\n   * @param nonce The contract state required to match the signature\n   * @param expiry The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   **/\n  function delegateBySig(\n    address delegatee,\n    uint256 nonce,\n    uint256 expiry,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n"
    },
    "contracts/interfaces/IGovernanceStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity =0.8.23;\n\ninterface IGovernanceStrategy {\n  /**\n   * @dev Returns the Proposition Power of a user at a specific block number.\n   * @param user Address of the user.\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\n   * @return Power number\n   **/\n  function getPropositionPowerAt(address user, uint256 blockNumber) external view returns (uint256);\n  /**\n   * @dev Returns the total supply of Outstanding Proposition Tokens \n   * @param blockNumber Blocknumber at which to evaluate\n   * @return total supply at blockNumber\n   **/\n  function getTotalPropositionSupplyAt(uint256 blockNumber) external view returns (uint256);\n  /**\n   * @dev Returns the total supply of Outstanding Voting Tokens \n   * @param blockNumber Blocknumber at which to evaluate\n   * @return total supply at blockNumber\n   **/\n  function getTotalVotingSupplyAt(uint256 blockNumber) external view returns (uint256);\n  /**\n   * @dev Returns the Vote Power of a user at a specific block number.\n   * @param user Address of the user.\n   * @param blockNumber Blocknumber at which to fetch Vote Power\n   * @return Vote number\n   **/\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IProposalValidator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity =0.8.23;\n\nimport {IGovernance} from './IGovernance.sol';\n\ninterface IProposalValidator {\n\n  /**\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\n   * @param governance Governance Contract\n   * @param user Address of the proposal creator\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\n   * @return boolean, true if can be created\n   **/\n  function validateCreatorOfProposal(\n    IGovernance governance,\n    address user,\n    uint256 blockNumber\n  ) external view returns (bool);\n\n  /**\n   * @dev Called to validate the cancellation of a proposal\n   * @param governance Governance Contract\n   * @param user Address of the proposal creator\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\n   * @return boolean, true if can be cancelled\n   **/\n  function validateProposalCancellation(\n    IGovernance governance,\n    address user,\n    uint256 blockNumber\n  ) external view returns (bool);\n\n  /**\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\n   * @param governance Governance Contract\n   * @param user Address of the user to be challenged.\n   * @param blockNumber Block Number against which to make the challenge.\n   * @return true if user has enough power\n   **/\n  function isPropositionPowerEnough(\n    IGovernance governance,\n    address user,\n    uint256 blockNumber\n  ) external view returns (bool);\n\n  /**\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\n   * @param governance Governance Contract\n   * @param blockNumber Blocknumber at which to evaluate\n   * @return minimum Proposition Power needed\n   **/\n  function getMinimumPropositionPowerNeeded(IGovernance governance, uint256 blockNumber)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Returns whether a proposal passed or not\n   * @param governance Governance Contract\n   * @param proposalId Id of the proposal to set\n   * @return true if proposal passed\n   **/\n  function isProposalPassed(IGovernance governance, uint256 proposalId)\n    external\n    view\n    returns (bool);\n\n  /**\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\n   * @param governance Governance Contract\n   * @param proposalId Id of the proposal to verify\n   * @return voting power needed for a proposal to pass\n   **/\n  function isQuorumValid(IGovernance governance, uint256 proposalId)\n    external\n    view\n    returns (bool);\n\n  /**\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\n   * @param governance Governance Contract\n   * @param proposalId Id of the proposal to verify\n   * @return true if enough For-Votes\n   **/\n  function isVoteDifferentialValid(IGovernance governance, uint256 proposalId)\n    external\n    view\n    returns (bool);\n\n  /**\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\n   * @param votingSupply Total number of oustanding voting tokens\n   * @return voting power needed for a proposal to pass\n   **/\n  function getMinimumVotingPowerNeeded(uint256 votingSupply) external view returns (uint256);\n\n  /**\n   * @dev Get proposition threshold constant value\n   * @return the proposition threshold value (100 <=> 1%)\n   **/\n  function PROPOSITION_THRESHOLD() external view returns (uint256);\n\n  /**\n   * @dev Get voting duration constant value\n   * @return the voting duration value in seconds\n   **/\n  function VOTING_DURATION() external view returns (uint256);\n\n  /**\n   * @dev Get the vote differential threshold constant value\n   * to compare with % of for votes/total supply - % of against votes/total supply\n   * @return the vote differential threshold value (100 <=> 1%)\n   **/\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\n\n  /**\n   * @dev Get quorum threshold constant value\n   * to compare with % of for votes/total supply\n   * @return the quorum threshold value (100 <=> 1%)\n   **/\n  function MINIMUM_QUORUM() external view returns (uint256);\n\n  /**\n   * @dev precision helper: 100% = 10000\n   * @return one hundred percents with our chosen precision\n   **/\n  function ONE_HUNDRED_WITH_PRECISION() external view returns (uint256);\n\n}\n"
    },
    "contracts/interfaces/IVotingStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity =0.8.23;\n\ninterface IVotingStrategy {\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/pool/IOwnership.sol": {
      "content": "pragma solidity =0.8.23;\n\n//SPDX-License-Identifier: MIT\n\ninterface IOwnership {\n    function owner() external view returns (address);\n\n    function futureOwner() external view returns (address);\n\n    function commitTransferOwnership(address newOwner) external;\n\n    function acceptTransferOwnership() external;\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.11;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n"
    },
    "contracts/misc/Helpers.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity =0.8.23;\n\nfunction getChainId() view returns (uint256) {\n  uint256 chainId;\n  assembly {\n    chainId := chainid()\n  }\n  return chainId;\n}\n\nfunction isContract(address account) view returns (bool) {\n  // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n  // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n  // for accounts without code, i.e. `keccak256('')`\n  bytes32 codehash;\n  bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n  // solhint-disable-next-line no-inline-assembly\n  assembly {\n    codehash := extcodehash(account)\n  }\n  return (codehash != accountHash && codehash != 0x0);\n}\n"
    },
    "contracts/mocks/MockUno.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity =0.8.23;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MockUno is Ownable, ERC20 {\n    uint256 INITIAL_SUPPLY = 10000000000 * 10 ** 18;\n\n    constructor(\n        string memory _name_,\n        string memory _symbol_\n    ) ERC20(_name_, _symbol_) Ownable(msg.sender) {}\n\n    function faucet(uint256 _amount) external {\n        _mint(msg.sender, _amount);\n    }\n}\n"
    },
    "contracts/mocks/SmartWalletChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.23;\n\ncontract SmartWalletCheckerMock {\n    function check(address) external view returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/Ownership.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.23;\n\nimport \"./interfaces/pool/IOwnership.sol\";\n\ncontract Ownership is IOwnership {\n    address private _owner;\n    address private _futureOwner;\n\n    event CommitNewOwnership(address indexed futureOwner);\n    event AcceptNewOwnership(address indexed owner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _owner = msg.sender;\n        emit AcceptNewOwnership(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() external view override returns (address) {\n        return _owner;\n    }\n\n    function futureOwner() external view override returns (address) {\n        return _futureOwner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Caller is not allowed to operate\");\n        _;\n    }\n\n    modifier onlyFutureOwner() {\n        require(_futureOwner == msg.sender, \"Caller is not allowed to operate\");\n        _;\n    }\n\n    /***\n     *@notice Transfer ownership of GaugeController to `newOwner`\n     *@param newOwner Address to have ownership transferred to\n     */\n    function commitTransferOwnership(address newOwner)\n        external\n        override\n        onlyOwner\n    {\n        _futureOwner = newOwner;\n        emit CommitNewOwnership(newOwner);\n    }\n\n    /***\n     *@notice Accept a transfer of ownership\n     */\n    function acceptTransferOwnership() external override onlyFutureOwner {\n        _owner = msg.sender;\n        _futureOwner = address(0);\n        emit AcceptNewOwnership(msg.sender);\n    }\n}\n"
    },
    "contracts/safe/base/Executor.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/Enum.sol\";\n\n/// @title Executor - A contract that can execute transactions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Executor {\n    function execute(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 txGas\n    ) internal returns (bool success) {\n        if (operation == Enum.Operation.DelegateCall) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n            }\n        } else {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n            }\n        }\n    }\n}"
    },
    "contracts/safe/base/FallbackManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract FallbackManager is SelfAuthorized {\n    event ChangedFallbackHandler(address handler);\n\n    // keccak256(\"fallback_manager.handler.address\")\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\n    function internalSetFallbackHandler(address handler) internal {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, handler)\n        }\n    }\n\n    /// @dev Allows to add a contract to handle fallback calls.\n    ///      Only fallback calls without value and with data will be forwarded.\n    ///      This can only be done via a Safe transaction.\n    /// @param handler contract to handle fallbacks calls.\n    function setFallbackHandler(address handler) public authorized {\n        internalSetFallbackHandler(handler);\n        emit ChangedFallbackHandler(handler);\n    }\n\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\n    fallback() external {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let handler := sload(slot)\n            if iszero(handler) {\n                return(0, 0)\n            }\n            calldatacopy(0, 0, calldatasize())\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            mstore(calldatasize(), shl(96, caller()))\n            // Add 20 bytes for the address appended add the end\n            let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if iszero(success) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}"
    },
    "contracts/safe/base/GuardManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\n\ninterface Guard {\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external;\n\n    function checkAfterExecution(bytes32 txHash, bool success) external;\n}\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract GuardManager is SelfAuthorized {\n    event ChangedGuard(address guard);\n    // keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Set a guard that checks transactions before execution\n    /// @param guard The address of the guard to be used or the 0 address to disable the guard\n    function setGuard(address guard) external authorized {\n        bytes32 slot = GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, guard)\n        }\n        emit ChangedGuard(guard);\n    }\n\n    function getGuard() internal view returns (address guard) {\n        bytes32 slot = GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            guard := sload(slot)\n        }\n    }\n}"
    },
    "contracts/safe/base/ModuleManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\nimport \"./Executor.sol\";\n\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract ModuleManager is SelfAuthorized, Executor {\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    mapping(address => address) internal modules;\n\n    function setupModules(address to, bytes memory data) internal {\n        require(modules[SENTINEL_MODULES] == address(0), \"GS100\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), \"GS000\");\n    }\n\n    /// @dev Allows to add a module to the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Enables the module `module` for the Safe.\n    /// @param module Module to be whitelisted.\n    function enableModule(address module) public authorized {\n        // Module address cannot be null or sentinel.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        // Module cannot be added twice.\n        require(modules[module] == address(0), \"GS102\");\n        modules[module] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = module;\n        emit EnabledModule(module);\n    }\n\n    /// @dev Allows to remove a module from the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Disables the module `module` for the Safe.\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(address prevModule, address module) public authorized {\n        // Validate module address and check that it corresponds to module index.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        require(modules[prevModule] == module, \"GS103\");\n        modules[prevModule] = modules[module];\n        modules[module] = address(0);\n        emit DisabledModule(module);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public virtual returns (bool success) {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"GS104\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public returns (bool success, bytes memory returnData) {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) public view returns (bool) {\n        return SENTINEL_MODULES != module && modules[module] != address(0);\n    }\n\n    /// @dev Returns array of modules.\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while (currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }\n}"
    },
    "contracts/safe/base/OwnerManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract OwnerManager is SelfAuthorized {\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 internal ownerCount;\n    uint256 internal threshold;\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    function setupOwners(address[] memory _owners, uint256 _threshold) internal {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"GS200\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"GS201\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"GS202\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this) && currentOwner != owner, \"GS203\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"GS204\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\n    /// @param owner New owner address.\n    /// @param _threshold New threshold.\n    function addOwnerWithThreshold(address owner, uint256 _threshold) public authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this), \"GS203\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"GS204\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\n    /// @param owner Owner address to be removed.\n    /// @param _threshold New threshold.\n    function removeOwner(\n        address prevOwner,\n        address owner,\n        uint256 _threshold\n    ) public authorized {\n        // Only allow to remove an owner, if threshold can still be reached.\n        require(ownerCount - 1 >= _threshold, \"GS201\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"GS203\");\n        require(owners[prevOwner] == owner, \"GS205\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to swap/replace an owner from the Safe with another address.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\n    /// @param oldOwner Owner address to be replaced.\n    /// @param newOwner New owner address.\n    function swapOwner(\n        address prevOwner,\n        address oldOwner,\n        address newOwner\n    ) public authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS && newOwner != address(this), \"GS203\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"GS204\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"GS203\");\n        require(owners[prevOwner] == oldOwner, \"GS205\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    /// @dev Allows to update the number of required confirmations by Safe owners.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Changes the threshold of the Safe to `_threshold`.\n    /// @param _threshold New threshold.\n    function changeThreshold(uint256 _threshold) public authorized {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"GS201\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"GS202\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold() public view returns (uint256) {\n        return threshold;\n    }\n\n    function isOwner(address owner) public view returns (bool) {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }\n\n    /// @dev Returns array of owners.\n    /// @return Array of Safe owners.\n    function getOwners() public view returns (address[] memory) {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index++;\n        }\n        return array;\n    }\n}"
    },
    "contracts/safe/common/Enum.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}"
    },
    "contracts/safe/common/EtherPaymentFallback.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract EtherPaymentFallback {\n    event SafeReceived(address indexed sender, uint256 value);\n\n    /// @dev Fallback function accepts Ether transactions.\n    receive() external payable {\n        emit SafeReceived(msg.sender, msg.value);\n    }\n}"
    },
    "contracts/safe/common/SecuredTokenTransfer.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SecuredTokenTransfer - Secure token transfer\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SecuredTokenTransfer {\n    /// @dev Transfers a token and returns if it was a success\n    /// @param token Token that should be transferred\n    /// @param receiver Receiver to whom the token should be transferred\n    /// @param amount The amount of tokens that should be transferred\n    function transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal returns (bool transferred) {\n        // 0xa9059cbb - keccack(\"transfer(address,uint256)\")\n        bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver, amount);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We write the return value to scratch space.\n            // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory\n            let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            switch returndatasize()\n                case 0 {\n                    transferred := success\n                }\n                case 0x20 {\n                    transferred := iszero(or(iszero(success), iszero(mload(0))))\n                }\n                default {\n                    transferred := 0\n                }\n        }\n    }\n}"
    },
    "contracts/safe/common/SelfAuthorized.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SelfAuthorized - authorizes current contract to perform actions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SelfAuthorized {\n    function requireSelfCall() private view {\n        require(msg.sender == address(this), \"GS031\");\n    }\n\n    modifier authorized() {\n        // This is a function call as it minimized the bytecode size\n        requireSelfCall();\n        _;\n    }\n}"
    },
    "contracts/safe/common/SignatureDecoder.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SignatureDecoder {\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\n    /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\n    /// @param signatures concatenated rsv signatures\n    function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }\n}"
    },
    "contracts/safe/common/Singleton.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Singleton - Base for singleton contracts (should always be first super contract)\n///         This contract is tightly coupled to our proxy contract (see `proxies/GnosisSafeProxy.sol`)\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract Singleton {\n    // singleton always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\n    // It should also always be ensured that the address is stored alone (uses a full word)\n    address private singleton;\n}"
    },
    "contracts/safe/common/StorageAccessible.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title StorageAccessible - generic base contract that allows callers to access all internal storage.\n/// @notice See https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol\ncontract StorageAccessible {\n    /**\n     * @dev Reads `length` bytes of storage in the currents contract\n     * @param offset - the offset in the current contract's storage in words to start reading from\n     * @param length - the number of words (32 bytes) of data to read\n     * @return the bytes that were read.\n     */\n    function getStorageAt(uint256 offset, uint256 length) public view returns (bytes memory) {\n        bytes memory result = new bytes(length * 32);\n        for (uint256 index = 0; index < length; index++) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let word := sload(add(offset, index))\n                mstore(add(add(result, 0x20), mul(index, 0x20)), word)\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Performs a delegetecall on a targetContract in the context of self.\n     * Internally reverts execution to avoid side effects (making it static).\n     *\n     * This method reverts with data equal to `abi.encode(bool(success), bytes(response))`.\n     * Specifically, the `returndata` after a call to this method will be:\n     * `success:bool || response.length:uint256 || response:bytes`.\n     *\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let success := delegatecall(gas(), targetContract, add(calldataPayload, 0x20), mload(calldataPayload), 0, 0)\n\n            mstore(0x00, success)\n            mstore(0x20, returndatasize())\n            returndatacopy(0x40, 0, returndatasize())\n            revert(0, add(returndatasize(), 0x40))\n        }\n    }\n}"
    },
    "contracts/safe/external/GnosisSafeMath.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title GnosisSafeMath\n * @dev Math operations with safety checks that revert on error\n * Renamed from SafeMath to GnosisSafeMath to avoid conflicts\n * TODO: remove once open zeppelin update to solc 0.5.0\n */\nlibrary GnosisSafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n}"
    },
    "contracts/safe/GnosisSafe.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./base/ModuleManager.sol\";\nimport \"./base/OwnerManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./base/GuardManager.sol\";\nimport \"./common/EtherPaymentFallback.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./common/StorageAccessible.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./external/GnosisSafeMath.sol\";\n\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafe is\n    EtherPaymentFallback,\n    Singleton,\n    ModuleManager,\n    OwnerManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    ISignatureValidatorConstants,\n    FallbackManager,\n    StorageAccessible,\n    GuardManager\n{\n    using GnosisSafeMath for uint256;\n\n    string public constant VERSION = \"1.3.0\";\n\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\n    event SignMsg(bytes32 indexed msgHash);\n    event ExecutionFailure(bytes32 txHash, uint256 payment);\n    event ExecutionSuccess(bytes32 txHash, uint256 payment);\n\n    uint256 public nonce;\n    bytes32 private _deprecatedDomainSeparator;\n    // Mapping to keep track of all message hashes that have been approve by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approve by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a master copy for Proxy contracts\n    constructor() {\n        // By setting the threshold it is not possible to call setup anymore,\n        // so we create a Safe with 0 owners and threshold 1.\n        // This is an unusable Safe, perfect for the singleton\n        threshold = 1;\n    }\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    /// @param to Contract address for optional delegate call.\n    /// @param data Data payload for optional delegate call.\n    /// @param fallbackHandler Handler for fallback calls to this contract\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\n    /// @param payment Value that should be paid\n    /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external {\n        // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n        emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);\n    }\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    ///      Note: The fees are always transferred, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable virtual returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData =\n                encodeTransactionData(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    nonce\n                );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n        address guard = getGuard();\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, \"GS010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || safeTxGas != 0 || gasPrice != 0, \"GS013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkAfterExecution(txHash, success);\n            }\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            require(receiver.send(payment), \"GS011\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            require(transferToken(gasToken, receiver, payment), \"GS012\");\n        }\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        require(_threshold > 0, \"GS001\");\n        checkNSignatures(dataHash, data, signatures, _threshold);\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     * @param requiredSignatures Amount of required valid signatures.\n     */\n    function checkNSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures,\n        uint256 requiredSignatures\n    ) public view {\n        // Check that the provided signature data is not too short\n        require(signatures.length >= requiredSignatures.mul(65), \"GS020\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < requiredSignatures; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= requiredSignatures.mul(65), \"GS021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s).add(32) <= signatures.length, \"GS022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"GS023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"GS024\");\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"GS025\");\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n            require(currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS, \"GS026\");\n            lastOwner = currentOwner;\n        }\n    }\n\n    /// @dev Allows to estimate a Safe transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    /// @notice Deprecated in favor of common/StorageAccessible.sol and will be removed in next version.\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.\n     * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.\n     */\n    function approveHash(bytes32 hashToApprove) external {\n        require(owners[msg.sender] != address(0), \"GS030\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Gas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    SAFE_TX_TYPEHASH,\n                    to,\n                    value,\n                    keccak256(data),\n                    operation,\n                    safeTxGas,\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    /// @dev Returns hash to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n    }\n}"
    },
    "contracts/safe/GnosisSafeL2.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./GnosisSafe.sol\";\n\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafeL2 is GnosisSafe {\n    event SafeMultiSigTransaction(\n        address to,\n        uint256 value,\n        bytes data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes signatures,\n        // We combine nonce, sender and threshold into one to avoid stack too deep\n        // Dev note: additionalInfo should not contain `bytes`, as this complicates decoding\n        bytes additionalInfo\n    );\n\n    event SafeModuleTransaction(address module, address to, uint256 value, bytes data, Enum.Operation operation);\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    ///      Note: The fees are always transferred, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable override returns (bool) {\n        bytes memory additionalInfo;\n        {\n            additionalInfo = abi.encode(nonce, msg.sender, threshold);\n        }\n        emit SafeMultiSigTransaction(\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver,\n            signatures,\n            additionalInfo\n        );\n        return super.execTransaction(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, signatures);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public override returns (bool success) {\n        emit SafeModuleTransaction(msg.sender, to, value, data, operation);\n        success = super.execTransactionFromModule(to, value, data, operation);\n    }\n}"
    },
    "contracts/safe/interfaces/ISignatureValidator.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\ncontract ISignatureValidatorConstants {\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\n}\n\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _data Arbitrary length data signed on the behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);\n}"
    },
    "contracts/SmartWalletChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.23;\n\ncontract SmartWalletChecker {\n    function check(address account) external view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size == 0;\n    }\n}\n"
    },
    "contracts/VotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/***\n *@title VotingEscrow\n *@notice Votes have a weight depending on time, so that users are\n *        committed to the future of (whatever they are voting for)\n *@dev Vote weight decays linearly over time. Lock time cannot be\n *     more than `MAXTIME` (4 years).\n */\n\n// Voting escrow to have time-weighted votes\n// Votes have a weight depending on time, so that users are committed\n// to the future of (whatever they are voting for).\n// The weight in this implementation is linear, and lock cannot be more than maxtime\n// w ^\n// 1 +        /\n//   |      /\n//   |    /\n//   |  /\n//   |/\n// 0 +--------+------> time\n//       maxtime (4 years?)\n\n// Interface for checking whether address belongs to a whitelisted\n// type of a smart wallet.\n// When new types are added - the whole contract is changed\n// The check() method is modifying to be able to use caching\n// for individual wallet addresses\nimport \"./interfaces/dao/ISmartWalletChecker.sol\";\n\nimport \"./interfaces/pool/IOwnership.sol\";\n\n//libraries\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ncontract VotingEscrow is ReentrancyGuard {\n    struct Point {\n        int256 bias;\n        int256 slope; // - dweight / dt\n        uint256 ts; //timestamp\n        uint256 blk; // block\n    }\n    // We cannot really do block numbers per se b/c slope is per time, not per block\n    // and per block could be fairly bad b/c Ethereum changes blocktimes.\n    // What we can do is to extrapolate ***At functions\n\n    struct LockedBalance {\n        int256 amount;\n        uint256 end;\n    }\n\n    int256 constant DEPOSIT_FOR_TYPE = 0;\n    int256 constant CREATE_LOCK_TYPE = 1;\n    int256 constant INCREASE_LOCK_AMOUNT = 2;\n    int256 constant INCREASE_UNLOCK_TIME = 3;\n\n    event Deposit(\n        address indexed provider,\n        uint256 value,\n        uint256 indexed locktime,\n        int256 _type,\n        uint256 ts\n    );\n    event Withdraw(address indexed provider, uint256 value, uint256 ts);\n    event ForceUnlock(address target, uint256 value, uint256 ts);\n\n    event Supply(uint256 prevSupply, uint256 supply);\n\n    event commitWallet(address newSmartWalletChecker);\n    event applyWallet(address newSmartWalletChecker);\n\n    uint256 constant WEEK = 7 * 86400; // all future times are rounded by week\n    uint256 constant MAXTIME = 4 * 365 * 86400; // 4 years\n    uint256 constant MULTIPLIER = 10**18;\n\n    address public token;\n    uint256 public supply;\n\n    mapping(address => LockedBalance) public locked;\n\n    //everytime user deposit/withdraw/change_locktime, these values will be updated;\n    uint256 public epoch;\n    Point[100000000000000000000000000000] public point_history; // epoch -> unsigned point.\n    mapping(address => Point[1000000000]) public user_point_history; // user -> Point[user_epoch]\n    mapping(address => uint256) public user_point_epoch;\n    mapping(uint256 => int256) public slope_changes; // time -> signed slope change\n\n    // Aragon's view methods for compatibility\n    address public controller;\n    bool public transfersEnabled;\n\n    string public name;\n    string public symbol;\n    string public version;\n    uint256 public constant decimals = 18;\n\n    // Checker for whitelisted (smart contract) wallets which are allowed to deposit\n    // The goal is to prevent tokenizing the escrow\n    address public future_smart_wallet_checker;\n    address public smart_wallet_checker;\n\n    IOwnership public immutable ownership;\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    /***\n     *@notice Contract constructor\n     *@param token_addr `UNO` token address\n     *@param _name Token name\n     *@param _symbol Token symbol\n     *@param _version Contract version - required for Aragon compatibility\n     */\n    constructor(\n        address _token_addr,\n        string memory _name,\n        string memory _symbol,\n        string memory _version,\n        address _ownership\n    ) {\n        ownership = IOwnership(_ownership);\n        token = _token_addr;\n        point_history[0].blk = block.number;\n        point_history[0].ts = block.timestamp;\n        controller = msg.sender;\n        transfersEnabled = true;\n\n        name = _name;\n        symbol = _symbol;\n        version = _version;\n    }\n\n    /***\n     *@notice Check if the call is from a whitelisted smart contract, revert if not\n     *@param _addr Address to be checked\n     */\n    function assert_not_contract(address _addr) internal {\n        if (_addr != tx.origin) {\n            address checker = smart_wallet_checker; //not going to be deployed at the moment of launch.\n            if (checker != address(0)) {\n                if (ISmartWalletChecker(checker).check(_addr)) {\n                    return;\n                }\n            }\n            revert(\"contract depositors not allowed\");\n        }\n    }\n\n    /***\n     *@notice Get the most recently recorded rate of voting power decrease for `_addr`\n     *@param _addr Address of the user wallet\n     *@return Value of the slope\n     */\n    function get_last_user_slope(address _addr)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 uepoch = user_point_epoch[_addr];\n        return uint256(user_point_history[_addr][uepoch].slope);\n    }\n\n    /***\n     *@notice Get the timestamp for checkpoint `_idx` for `_addr`\n     *@param _addr User wallet address\n     *@param _idx User epoch number\n     *@return Epoch time of the checkpoint\n     */\n    function user_point_history__ts(address _addr, uint256 _idx)\n        external\n        view\n        returns (uint256)\n    {\n        return user_point_history[_addr][_idx].ts;\n    }\n\n    /***\n     *@notice Get timestamp when `_addr`'s lock finishes\n     *@param _addr User wallet\n     *@return Epoch time of the lock end\n     */\n    function locked__end(address _addr) external view returns (uint256) {\n        return locked[_addr].end;\n    }\n\n    /***\n     *@notice Record global and per-user data to checkpoint\n     *@param _addr User's wallet address. No user checkpoint if 0x0\n     *@param _old_locked Pevious locked amount / end lock time for the user\n     *@param _new_locked New locked amount / end lock time for the user\n     */\n    function _checkpoint(\n        address _addr,\n        LockedBalance memory _old_locked,\n        LockedBalance memory _new_locked\n    ) internal {\n        Point memory _u_old;\n        Point memory _u_new;\n        int256 _old_dslope = 0;\n        int256 _new_dslope = 0;\n        uint256 _epoch = epoch;\n\n        if (_addr != address(0)) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (_old_locked.end > block.timestamp && _old_locked.amount > 0) {\n                unchecked {\n                    _u_old.slope = _old_locked.amount / int256(MAXTIME);\n                }\n                _u_old.bias =\n                    _u_old.slope *\n                    int256(_old_locked.end - block.timestamp);\n            }\n            if (_new_locked.end > block.timestamp && _new_locked.amount > 0) {\n                unchecked {\n                    _u_new.slope = _new_locked.amount / int256(MAXTIME);\n                }\n                _u_new.bias =\n                    _u_new.slope *\n                    int256(_new_locked.end - block.timestamp);\n            }\n\n            // Read values of scheduled changes in the slope\n            // _old_locked.end can be in the past and in the future\n            // _new_locked.end can ONLY by in the FUTURE unless everything expired than zeros\n            _old_dslope = slope_changes[_old_locked.end];\n            if (_new_locked.end != 0) {\n                if (_new_locked.end == _old_locked.end) {\n                    _new_dslope = _old_dslope;\n                } else {\n                    _new_dslope = slope_changes[_new_locked.end];\n                }\n            }\n        }\n        Point memory _last_point = Point({\n            bias: 0,\n            slope: 0,\n            ts: block.timestamp,\n            blk: block.number\n        });\n        if (_epoch > 0) {\n            _last_point = point_history[_epoch];\n        }\n        uint256 _last_checkpoint = _last_point.ts;\n        // _initial_last_point is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        Point memory _initial_last_point = _last_point;\n        uint256 _block_slope = 0; // dblock/dt\n        if (block.timestamp > _last_point.ts) {\n            _block_slope =\n                (MULTIPLIER * (block.number - _last_point.blk)) /\n                (block.timestamp - _last_point.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        uint256 _t_i;\n        unchecked {\n            _t_i = (_last_checkpoint / WEEK) * WEEK;\n        }\n        for (uint256 i; i < 255; ) {\n            // Hopefully it won't happen that this won't get used in 5 years!\n            // If it does, users will be able to withdraw but vote weight will be broken\n            _t_i += WEEK;\n            int256 d_slope = 0;\n            if (_t_i > block.timestamp) {\n                _t_i = block.timestamp;\n            } else {\n                d_slope = slope_changes[_t_i];\n            }\n            _last_point.bias =\n                _last_point.bias -\n                _last_point.slope *\n                int256(_t_i - _last_checkpoint);\n            _last_point.slope += d_slope;\n            if (_last_point.bias < 0) {\n                // This can happen\n                _last_point.bias = 0;\n            }\n            if (_last_point.slope < 0) {\n                // This cannot happen - just in case\n                _last_point.slope = 0;\n            }\n            _last_checkpoint = _t_i;\n            _last_point.ts = _t_i;\n            _last_point.blk =\n                _initial_last_point.blk +\n                ((_block_slope * (_t_i - _initial_last_point.ts)) / MULTIPLIER);\n            _epoch += 1;\n            if (_t_i == block.timestamp) {\n                _last_point.blk = block.number;\n                break;\n            } else {\n                point_history[_epoch] = _last_point;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        epoch = _epoch;\n        // Now point_history is filled until t=now\n\n        if (_addr != address(0)) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            _last_point.slope += _u_new.slope - _u_old.slope;\n            _last_point.bias += _u_new.bias - _u_old.bias;\n            if (_last_point.slope < 0) {\n                _last_point.slope = 0;\n            }\n            if (_last_point.bias < 0) {\n                _last_point.bias = 0;\n            }\n        }\n        // Record the changed point into history\n        point_history[_epoch] = _last_point;\n\n        address _addr2 = _addr; //To avoid being \"Stack Too Deep\"\n\n        if (_addr2 != address(0)) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [_new_locked.end]\n            // and add old_user_slope to [_old_locked.end]\n            if (_old_locked.end > block.timestamp) {\n                // _old_dslope was <something> - _u_old.slope, so we cancel that\n                _old_dslope += _u_old.slope;\n                if (_new_locked.end == _old_locked.end) {\n                    _old_dslope -= _u_new.slope; // It was a new deposit, not extension\n                }\n                slope_changes[_old_locked.end] = _old_dslope;\n            }\n            if (_new_locked.end > block.timestamp) {\n                if (_new_locked.end > _old_locked.end) {\n                    _new_dslope -= _u_new.slope; // old slope disappeared at this point\n                    slope_changes[_new_locked.end] = _new_dslope;\n                }\n                // else we recorded it already in _old_dslope\n            }\n\n            // Now handle user history\n            uint256 _user_epoch;\n            unchecked {\n                _user_epoch = user_point_epoch[_addr2] + 1;\n            }\n\n            user_point_epoch[_addr2] = _user_epoch;\n            _u_new.ts = block.timestamp;\n            _u_new.blk = block.number;\n            user_point_history[_addr2][_user_epoch] = _u_new;\n        }\n    }\n\n    /***\n     *@notice Deposit and lock tokens for a user\n     *@param _depositor Spender's wallet address\n     *@param _beneficiary Beneficiary's wallet address\n     *@param _value Amount to deposit\n     *@param _unlock_time New time when to unlock the tokens, or 0 if unchanged\n     *@param _locked_balance Previous locked amount / timestamp\n     */\n    function _deposit_for(\n        address _depositor,\n        address _beneficiary,\n        uint256 _value,\n        uint256 _unlock_time,\n        LockedBalance memory _locked_balance,\n        int256 _type\n    ) internal {\n        LockedBalance memory _locked = LockedBalance(\n            _locked_balance.amount,\n            _locked_balance.end\n        );\n        LockedBalance memory _old_locked = LockedBalance(\n            _locked_balance.amount,\n            _locked_balance.end\n        );\n\n        uint256 _supply_before = supply;\n        supply = _supply_before + _value;\n        //Adding to existing lock, or if a lock is expired - creating a new one\n        _locked.amount = _locked.amount + int256(_value);\n        if (_unlock_time != 0) {\n            _locked.end = _unlock_time;\n        }\n        locked[_beneficiary] = _locked;\n\n        // Possibilities\n        // Both _old_locked.end could be current or expired (>/< block.timestamp)\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n        // _locked.end > block.timestamp (always)\n\n        _checkpoint(_beneficiary, _old_locked, _locked);\n\n        if (_value != 0) {\n            require(\n                IERC20(token).transferFrom(_depositor, address(this), _value)\n            );\n        }\n\n        emit Deposit(_beneficiary, _value, _locked.end, _type, block.timestamp);\n        emit Supply(_supply_before, _supply_before + _value);\n    }\n\n    function checkpoint() public {\n        /***\n         *@notice Record global data to checkpoint\n         */\n        LockedBalance memory _a;\n        LockedBalance memory _b;\n        _checkpoint(address(0), _a, _b);\n    }\n\n    /***\n     *@notice Deposit `_value` tokens for `_addr` and add to the lock\n     *@dev Anyone (even a smart contract) can deposit for someone else, but\n     *    cannot extend their locktime and deposit for a brand new user\n     *@param _addr User's wallet address\n     *@param _value Amount to add to user's lock\n     */\n    function deposit_for(address _addr, uint256 _value) external nonReentrant {\n        require(_value > 0, \"dev: need non-zero value\");\n        LockedBalance memory _locked = locked[_addr];\n\n        require(_locked.amount > 0, \"No existing lock found\");\n        require(_locked.end > block.timestamp, \"Cannot add to expired lock.\");\n\n        _deposit_for(msg.sender, _addr, _value, 0, _locked, DEPOSIT_FOR_TYPE);\n    }\n\n    /***\n     *@notice Deposit `_value` tokens for `msg.sender` and lock until `_unlock_time`\n     *@param _value Amount to deposit\n     *@param _unlock_time Epoch time period when tokens unlock, rounded down to whole weeks\n     */\n    function create_lock(uint256 _value, uint256 _unlock_time)\n        external\n        nonReentrant\n    {\n        assert_not_contract(msg.sender);\n        require(\n            _unlock_time > 0 && _unlock_time <= MAXTIME,\n            \"Can lock until time in future or Voting lock can be 4 years max\"\n        );\n        _unlock_time = block.timestamp + (_unlock_time / WEEK) * WEEK; // Locktime is rounded down to weeks\n        LockedBalance memory _locked = locked[msg.sender];\n\n        require(_value > 0, \"dev: need non-zero value\");\n        require(_locked.amount == 0, \"Withdraw old tokens first\");\n\n        _deposit_for(\n            msg.sender,\n            msg.sender,\n            _value,\n            _unlock_time,\n            _locked,\n            CREATE_LOCK_TYPE\n        );\n    }\n\n    /***\n     *@notice Deposit `_value` additional tokens for `msg.sender`\n     *        without modifying the unlock time\n     *@param _value Amount of tokens to deposit and add to the lock\n     */\n    function increase_amount(uint256 _value) external nonReentrant {\n        assert_not_contract(msg.sender);\n        LockedBalance memory _locked = locked[msg.sender];\n\n        require(_value > 0, \"dev: need non-zero value\");\n        require(_locked.amount > 0, \"No existing lock found\");\n        require(_locked.end > block.timestamp, \"Cannot add to expired lock.\");\n\n        _deposit_for(\n            msg.sender,\n            msg.sender,\n            _value,\n            0,\n            _locked,\n            INCREASE_LOCK_AMOUNT\n        );\n    }\n\n    /***\n     *@notice Extend the unlock time for `msg.sender` to `_unlock_time`\n     *@param _unlock_time New epoch time for unlocking\n     */\n    function increase_unlock_time(uint256 _unlock_time) external nonReentrant {\n        assert_not_contract(msg.sender); //@shun: need to convert to solidity\n        LockedBalance memory _locked = locked[msg.sender];\n\n        require(_locked.end > block.timestamp, \"Lock expired\");\n        require(_locked.amount > 0, \"Nothing is locked\");\n\n        require(\n            _unlock_time > 0 && _unlock_time <= MAXTIME,\n            \"Can only increase lock duration or Voting lock can be 4 years max\"\n        );\n        unchecked {\n            _unlock_time = block.timestamp + (_unlock_time / WEEK) * WEEK; // Locktime is rounded down to weeks\n        }\n\n        _deposit_for(\n            msg.sender,\n            msg.sender,\n            0,\n            _unlock_time,\n            _locked,\n            INCREASE_UNLOCK_TIME\n        );\n    }\n\n    /***\n     *@notice Withdraw all tokens for `msg.sender`\n     *@dev Only possible if the lock has expired\n     */\n    function withdraw() external nonReentrant {\n        LockedBalance memory _locked = LockedBalance(\n            locked[msg.sender].amount,\n            locked[msg.sender].end\n        );\n\n        require(block.timestamp >= _locked.end, \"The lock didn't expire\");\n        uint256 _value = uint256(_locked.amount);\n\n        LockedBalance memory _old_locked = LockedBalance(\n            locked[msg.sender].amount,\n            locked[msg.sender].end\n        );\n\n        _locked.end = 0;\n        _locked.amount = 0;\n        locked[msg.sender] = _locked;\n        uint256 _supply_before = supply;\n        supply = _supply_before - _value;\n\n        // _old_locked can have either expired <= timestamp or zero end\n        // _locked has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(msg.sender, _old_locked, _locked);\n\n        require(IERC20(token).transfer(msg.sender, _value));\n\n        emit Withdraw(msg.sender, _value, block.timestamp);\n        emit Supply(_supply_before, _supply_before - _value);\n    }\n\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\n    // They measure the weights for the purpose of voting, so they don't represent\n    // real coins.\n\n    /***\n     *@notice Binary search to estimate timestamp for block number\n     *@param _block Block to find\n     *@param _max_epoch Don't go beyond this epoch\n     *@return Approximate timestamp for block\n     */\n    function find_block_epoch(uint256 _block, uint256 _max_epoch)\n        internal\n        view\n        returns (uint256)\n    {\n        // Binary search\n        uint256 _min = 0;\n        uint256 _max = _max_epoch;\n        unchecked {\n            for (uint256 i; i <= 128; i++) {\n                // Will be always enough for 128-bit numbers\n                if (_min >= _max) {\n                    break;\n                }\n                uint256 _mid = (_min + _max + 1) / 2;\n                if (point_history[_mid].blk <= _block) {\n                    _min = _mid;\n                } else {\n                    _max = _mid - 1;\n                }\n            }\n        }\n        return _min;\n    }\n\n    /***\n     *@notice Get the current voting power for `msg.sender`\n     *@dev Adheres to the ERC20 `balanceOf` interface for Metamask & Snapshot compatibility\n     *@param _addr User wallet address\n     *@return User's present voting power\n     */\n    function balanceOf(address _addr) external view returns (uint256) {\n        uint256 _t = block.timestamp;\n\n        uint256 _epoch = user_point_epoch[_addr];\n        if (_epoch == 0) {\n            return 0;\n        } else {\n            Point memory _last_point = user_point_history[_addr][_epoch];\n            _last_point.bias -= _last_point.slope * int256(_t - _last_point.ts);\n            if (_last_point.bias < 0) {\n                _last_point.bias = 0;\n            }\n            return uint256(_last_point.bias);\n        }\n    }\n\n    /***\n     *@notice Get the current voting power for `msg.sender`\n     *@dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n     *@param _addr User wallet address\n     *@param _t Epoch time to return voting power at\n     *@return User voting power\n     *@dev return the present voting power if _t is 0\n     */\n    function balanceOf(address _addr, uint256 _t)\n        external\n        view\n        returns (uint256)\n    {\n        if (_t == 0) {\n            _t = block.timestamp;\n        }\n\n        uint256 _epoch = user_point_epoch[_addr];\n        if (_epoch == 0) {\n            return 0;\n        } else {\n            Point memory _last_point = user_point_history[_addr][_epoch];\n            _last_point.bias -= _last_point.slope * int256(_t - _last_point.ts);\n            if (_last_point.bias < 0) {\n                _last_point.bias = 0;\n            }\n            return uint256(_last_point.bias);\n        }\n    }\n\n    //Struct to avoid \"Stack Too Deep\"\n    struct Parameters {\n        uint256 min;\n        uint256 max;\n        uint256 max_epoch;\n        uint256 d_block;\n        uint256 d_t;\n    }\n\n    /***\n     *@notice Measure voting power of `_addr` at block height `_block`\n     *@dev Adheres to MiniMe `balanceOfAt` interface https//github.com/Giveth/minime\n     *@param _addr User's wallet address\n     *@param _block Block to calculate the voting power at\n     *@return Voting power\n     */\n    function balanceOfAt(address _addr, uint256 _block)\n        external\n        view\n        returns (uint256)\n    {\n        // Copying and pasting totalSupply code because Vyper cannot pass by\n        // reference yet\n        require(_block <= block.number);\n\n        Parameters memory _st;\n\n        // Binary search\n        _st.min = 0;\n        _st.max = user_point_epoch[_addr];\n        unchecked {\n            for (uint256 i; i <= 128; i++) {\n                // Will be always enough for 128-bit numbers\n                if (_st.min >= _st.max) {\n                    break;\n                }\n                uint256 _mid = (_st.min + _st.max + 1) / 2;\n                if (user_point_history[_addr][_mid].blk <= _block) {\n                    _st.min = _mid;\n                } else {\n                    _st.max = _mid - 1;\n                }\n            }\n        }\n\n        Point memory _upoint = user_point_history[_addr][_st.min];\n\n        _st.max_epoch = epoch;\n        uint256 _epoch = find_block_epoch(_block, _st.max_epoch);\n        Point memory _point_0 = point_history[_epoch];\n        _st.d_block = 0;\n        _st.d_t = 0;\n        if (_epoch < _st.max_epoch) {\n            Point memory _point_1 = point_history[_epoch + 1];\n            _st.d_block = _point_1.blk - _point_0.blk;\n            _st.d_t = _point_1.ts - _point_0.ts;\n        } else {\n            _st.d_block = block.number - _point_0.blk;\n            _st.d_t = block.timestamp - _point_0.ts;\n        }\n        uint256 block_time = _point_0.ts;\n        if (_st.d_block != 0) {\n            block_time += (_st.d_t * (_block - _point_0.blk)) / _st.d_block;\n        }\n\n        _upoint.bias -= _upoint.slope * int256(block_time - _upoint.ts);\n        if (_upoint.bias >= 0) {\n            return uint256(_upoint.bias);\n        }\n    }\n\n    /***\n     *@notice Calculate total voting power at some point in the past\n     *@param point The point (bias/slope) to start search from\n     *@param t Time to calculate the total voting power at\n     *@return Total voting power at that time\n     */\n    function supply_at(Point memory point, uint256 t)\n        internal\n        view\n        returns (uint256)\n    {\n        Point memory _last_point = point;\n        uint256 _t_i;\n        unchecked {\n            _t_i = (_last_point.ts / WEEK) * WEEK;\n        }\n        for (uint256 i; i < 255; ) {\n            _t_i += WEEK;\n            int256 d_slope = 0;\n\n            if (_t_i > t) {\n                _t_i = t;\n            } else {\n                d_slope = slope_changes[_t_i];\n            }\n            _last_point.bias -=\n                _last_point.slope *\n                int256(_t_i - _last_point.ts);\n\n            if (_t_i == t) {\n                break;\n            }\n            _last_point.slope += d_slope;\n            _last_point.ts = _t_i;\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (_last_point.bias < 0) {\n            _last_point.bias = 0;\n        }\n        return uint256(_last_point.bias);\n    }\n\n    /***\n     *@notice Calculate total voting power\n     *@dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n     *@return Total voting power\n     */\n\n    function totalSupply() external view returns (uint256) {\n        uint256 _epoch = epoch;\n        Point memory _last_point = point_history[_epoch];\n\n        return supply_at(_last_point, block.timestamp);\n    }\n\n    /***\n     *@notice Calculate total voting power\n     *@dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n     *@return Total voting power\n     */\n    function totalSupply(uint256 _t) external view returns (uint256) {\n        if (_t == 0) {\n            _t = block.timestamp;\n        }\n\n        uint256 _epoch = epoch;\n        Point memory _last_point = point_history[_epoch];\n\n        return supply_at(_last_point, _t);\n    }\n\n    /***\n     *@notice Calculate total voting power at some point in the past\n     *@param _block Block to calculate the total voting power at\n     *@return Total voting power at `_block`\n     */\n    function totalSupplyAt(uint256 _block) external view returns (uint256) {\n        require(_block <= block.number);\n        uint256 _epoch = epoch;\n        uint256 _target_epoch = find_block_epoch(_block, _epoch);\n\n        Point memory _point = point_history[_target_epoch];\n        uint256 dt = 0;\n        if (_target_epoch < _epoch) {\n            Point memory _point_next = point_history[_target_epoch + 1];\n            if (_point.blk != _point_next.blk) {\n                dt =\n                    ((_block - _point.blk) * (_point_next.ts - _point.ts)) /\n                    (_point_next.blk - _point.blk);\n            }\n        } else {\n            if (_point.blk != block.number) {\n                dt =\n                    ((_block - _point.blk) * (block.timestamp - _point.ts)) /\n                    (block.number - _point.blk);\n            }\n        }\n        // Now dt contains info on how far are we beyond point\n\n        return supply_at(_point, _point.ts + dt);\n    }\n\n    /***\n     *@dev Dummy method required for Aragon compatibility\n     */\n    function changeController(address _newController) external {\n        require(msg.sender == controller);\n        controller = _newController;\n    }\n\n    function get_user_point_epoch(address _user)\n        external\n        view\n        returns (uint256)\n    {\n        return user_point_epoch[_user];\n    }\n\n    //---------------------- Admin Only ----------------------//\n    /***\n     *@notice Set an external contract to check for approved smart contract wallets\n     *@param _addr Address of Smart contract checker\n     */\n    function commit_smart_wallet_checker(address _addr) external onlyOwner {\n        future_smart_wallet_checker = _addr;\n\n        emit commitWallet(_addr);\n    }\n\n    /***\n     *@notice Apply setting external contract to check approved smart contract wallets\n     */\n    function apply_smart_wallet_checker() external onlyOwner {\n        address _future_smart_wallet_checker = future_smart_wallet_checker;\n        smart_wallet_checker = _future_smart_wallet_checker;\n\n        emit commitWallet(_future_smart_wallet_checker);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}